<?php

namespace Flarum\Foundation {
    abstract class AbstractServiceProvider extends \Illuminate\Support\ServiceProvider
    {
        /**
         * @deprecated perpetually, not removed because Laravel needs it.
         * @var Container
         */
        protected $app;
        /**
         * @var Container
         */
        protected $container;
        /**
         * @param Container $container
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
    }
}
namespace Flarum\Admin {
    class AdminServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot()
        {
        }
        /**
         * @param RouteCollection $routes
         */
        protected function populateRoutes(\Flarum\Http\RouteCollection $routes)
        {
        }
    }
}
namespace Flarum\Admin\Content {
    class AdminPayload
    {
        /**
         * @var Container;
         */
        protected $container;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        /**
         * @var ConnectionInterface
         */
        protected $db;
        /**
         * @param Container $container
         * @param SettingsRepositoryInterface $settings
         * @param ExtensionManager $extensions
         * @param ConnectionInterface $db
         * @param Dispatcher $events
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Settings\SettingsRepositoryInterface $settings, \Flarum\Extension\ExtensionManager $extensions, \Illuminate\Database\ConnectionInterface $db, \Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class Index
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        public function __construct(\Illuminate\Contracts\View\Factory $view, \Flarum\Extension\ExtensionManager $extensions, \Flarum\Settings\SettingsRepositoryInterface $settings)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request) : \Flarum\Frontend\Document
        {
        }
    }
}
namespace Flarum\Admin\Controller {
    class UpdateExtensionController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var Dispatcher
         */
        protected $bus;
        public function __construct(\Flarum\Http\UrlGenerator $url, \Flarum\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Admin\Middleware {
    class DisableBrowserCache implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class RequireAdministrateAbility implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Database {
    /**
     * Base model class, building on Eloquent.
     *
     * Adds the ability for custom relations to be added to a model during runtime.
     * These relations behave in the same way that you would expect; they can be
     * queried, eager loaded, and accessed as an attribute.
     * @mixin Eloquent
     * @mixin Relation
     */
    abstract class AbstractModel extends \Illuminate\Database\Eloquent\Model
    {
        /**
         * Indicates if the model should be timestamped. Turn off by default.
         *
         * @var bool
         */
        public $timestamps = false;
        /**
         * An array of callbacks to be run once after the model is saved.
         *
         * @var callable[]
         */
        protected $afterSaveCallbacks = [];
        /**
         * An array of callbacks to be run once after the model is deleted.
         *
         * @var callable[]
         */
        protected $afterDeleteCallbacks = [];
        /**
         * @internal
         */
        public static $customRelations = [];
        /**
         * @internal
         */
        public static $dateAttributes = [];
        /**
         * @internal
         */
        public static $defaults = [];
        /**
         * {@inheritdoc}
         */
        public static function boot()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __construct(array $attributes = [])
        {
        }
        /**
         * Get the attributes that should be converted to dates.
         *
         * @return array
         */
        public function getDates()
        {
        }
        /**
         * Get an attribute from the model. If nothing is found, attempt to load
         * a custom relation method with this key.
         *
         * @param string $key
         * @return mixed
         */
        public function getAttribute($key)
        {
        }
        /**
         * Get a custom relation object.
         *
         * @param string $name
         * @return mixed
         */
        protected function getCustomRelation($name)
        {
        }
        /**
         * Register a callback to be run once after the model is saved.
         *
         * @param callable $callback
         * @return void
         */
        public function afterSave($callback)
        {
        }
        /**
         * Register a callback to be run once after the model is deleted.
         *
         * @param callable $callback
         * @return void
         */
        public function afterDelete($callback)
        {
        }
        /**
         * @return callable[]
         */
        public function releaseAfterSaveCallbacks()
        {
        }
        /**
         * @return callable[]
         */
        public function releaseAfterDeleteCallbacks()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __call($method, $arguments)
        {
        }
    }
}
namespace Flarum\Api {
    /**
     * @property int $id
     * @property string $key
     * @property string|null $allowed_ips
     * @property string|null $scopes
     * @property int|null $user_id
     * @property \Flarum\User\User|null $user
     * @property \Carbon\Carbon $created_at
     * @property \Carbon\Carbon|null $last_activity_at
     */
    class ApiKey extends \Flarum\Database\AbstractModel
    {
        protected $dates = ['last_activity_at'];
        /**
         * Generate an API key.
         *
         * @return static
         */
        public static function generate()
        {
        }
        public function touch()
        {
        }
        public function user()
        {
        }
    }
    class ApiServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * Register notification serializers.
         */
        protected function setNotificationSerializers()
        {
        }
        /**
         * Populate the API routes.
         *
         * @param RouteCollection $routes
         */
        protected function populateRoutes(\Flarum\Http\RouteCollection $routes)
        {
        }
    }
    class Client
    {
        /**
         * @var MiddlewarePipeInterface
         */
        protected $pipe;
        /**
         * @var User
         */
        protected $actor;
        /**
         * @var ServerRequestInterface
         */
        protected $parent;
        /**
         * @var array
         */
        protected $queryParams = [];
        /**
         * @var array
         */
        protected $body = [];
        /**
         * @param MiddlewarePipeInterface $pipe
         */
        public function __construct(\Laminas\Stratigility\MiddlewarePipeInterface $pipe)
        {
        }
        /**
         * Set the request actor.
         * This is not needed if a parent request is provided.
         * It can, however, override the parent request's actor.
         */
        public function withActor(\Flarum\User\User $actor) : \Flarum\Api\Client
        {
        }
        public function withParentRequest(\Psr\Http\Message\ServerRequestInterface $parent) : \Flarum\Api\Client
        {
        }
        public function withQueryParams(array $queryParams) : \Flarum\Api\Client
        {
        }
        public function withBody(array $body) : \Flarum\Api\Client
        {
        }
        public function get(string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
        public function post(string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
        public function put(string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
        public function patch(string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
        public function delete(string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Execute the given API action class, pass the input and return its response.
         *
         * @param string $method
         * @param string $path
         * @return ResponseInterface
         *
         * @internal
         */
        public function send(string $method, string $path) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Api\Controller {
    abstract class AbstractSerializeController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * The name of the serializer class to output results with.
         *
         * @var string
         */
        public $serializer;
        /**
         * The relationships that are included by default.
         *
         * @var array
         */
        public $include = [];
        /**
         * The relationships that are available to be included.
         *
         * @var array
         */
        public $optionalInclude = [];
        /**
         * The maximum number of records that can be requested.
         *
         * @var int
         */
        public $maxLimit = 50;
        /**
         * The number of records included by default.
         *
         * @var int
         */
        public $limit = 20;
        /**
         * The fields that are available to be sorted by.
         *
         * @var array
         */
        public $sortFields = [];
        /**
         * The default sort field and order to user.
         *
         * @var array|null
         */
        public $sort;
        /**
         * @var Container
         */
        protected static $container;
        /**
         * @var array
         */
        protected static $beforeDataCallbacks = [];
        /**
         * @var array
         */
        protected static $beforeSerializationCallbacks = [];
        /**
         * @var string[]
         */
        protected static $loadRelations = [];
        /**
         * @var array<string, callable>
         */
        protected static $loadRelationCallables = [];
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Get the data to be serialized and assigned to the response document.
         *
         * @param ServerRequestInterface $request
         * @param Document $document
         * @return mixed
         */
        protected abstract function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document);
        /**
         * Create a PHP JSON-API Element for output in the document.
         *
         * @param mixed $data
         * @param SerializerInterface $serializer
         * @return \Tobscure\JsonApi\ElementInterface
         */
        protected abstract function createElement($data, \Tobscure\JsonApi\SerializerInterface $serializer);
        /**
         * Returns the relations to load added by extenders.
         *
         * @return string[]
         */
        protected function getRelationsToLoad() : array
        {
        }
        /**
         * Returns the relation callables to load added by extenders.
         *
         * @return array<string, callable>
         */
        protected function getRelationCallablesToLoad() : array
        {
        }
        /**
         * Eager loads the required relationships.
         */
        protected function loadRelations(\Illuminate\Database\Eloquent\Collection $models, array $relations, \Psr\Http\Message\ServerRequestInterface $request = null) : void
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return array
         * @throws \Tobscure\JsonApi\Exception\InvalidParameterException
         */
        protected function extractInclude(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return array
         */
        protected function extractFields(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return array|null
         * @throws \Tobscure\JsonApi\Exception\InvalidParameterException
         */
        protected function extractSort(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return int
         * @throws \Tobscure\JsonApi\Exception\InvalidParameterException
         */
        protected function extractOffset(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return int
         */
        protected function extractLimit(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return array
         */
        protected function extractFilter(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @return Parameters
         */
        protected function buildParameters(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        protected function sortIsDefault(\Psr\Http\Message\ServerRequestInterface $request) : bool
        {
        }
        /**
         * Set the serializer that will serialize data for the endpoint.
         *
         * @param string $serializer
         */
        public function setSerializer(string $serializer)
        {
        }
        /**
         * Include the given relationship by default.
         *
         * @param string|array $name
         */
        public function addInclude($name)
        {
        }
        /**
         * Don't include the given relationship by default.
         *
         * @param string|array $name
         */
        public function removeInclude($name)
        {
        }
        /**
         * Make the given relationship available for inclusion.
         *
         * @param string|array $name
         */
        public function addOptionalInclude($name)
        {
        }
        /**
         * Don't allow the given relationship to be included.
         *
         * @param string|array $name
         */
        public function removeOptionalInclude($name)
        {
        }
        /**
         * Set the default number of results.
         *
         * @param int $limit
         */
        public function setLimit(int $limit)
        {
        }
        /**
         * Set the maximum number of results.
         *
         * @param int $max
         */
        public function setMaxLimit(int $max)
        {
        }
        /**
         * Allow sorting results by the given field.
         *
         * @param string|array $field
         */
        public function addSortField($field)
        {
        }
        /**
         * Disallow sorting results by the given field.
         *
         * @param string|array $field
         */
        public function removeSortField($field)
        {
        }
        /**
         * Set the default sort order for the results.
         *
         * @param array $sort
         */
        public function setSort(array $sort)
        {
        }
        /**
         * @return Container
         */
        public static function getContainer()
        {
        }
        /**
         * @param Container $container
         *
         * @internal
         */
        public static function setContainer(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * @param string $controllerClass
         * @param callable $callback
         *
         * @internal
         */
        public static function addDataPreparationCallback(string $controllerClass, callable $callback)
        {
        }
        /**
         * @param string $controllerClass
         * @param callable $callback
         *
         * @internal
         */
        public static function addSerializationPreparationCallback(string $controllerClass, callable $callback)
        {
        }
        /**
         * @internal
         */
        public static function setLoadRelations(string $controllerClass, array $relations)
        {
        }
        /**
         * @internal
         */
        public static function setLoadRelationCallables(string $controllerClass, array $relations)
        {
        }
    }
    abstract class AbstractShowController extends \Flarum\Api\Controller\AbstractSerializeController
    {
        /**
         * {@inheritdoc}
         */
        protected function createElement($data, \Tobscure\JsonApi\SerializerInterface $serializer)
        {
        }
    }
    abstract class AbstractCreateController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    abstract class AbstractDeleteController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * Delete the resource.
         *
         * @param ServerRequestInterface $request
         */
        protected abstract function delete(\Psr\Http\Message\ServerRequestInterface $request);
    }
    abstract class AbstractListController extends \Flarum\Api\Controller\AbstractSerializeController
    {
        /**
         * {@inheritdoc}
         */
        protected function createElement($data, \Tobscure\JsonApi\SerializerInterface $serializer)
        {
        }
    }
    class ClearCacheController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var CacheClearCommand
         */
        protected $command;
        /**
         * @param CacheClearCommand $command
         */
        public function __construct(\Flarum\Foundation\Console\CacheClearCommand $command)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class CreateDiscussionController extends \Flarum\Api\Controller\AbstractCreateController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\DiscussionSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['posts', 'user', 'lastPostedUser', 'firstPost', 'lastPost'];
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class CreateGroupController extends \Flarum\Api\Controller\AbstractCreateController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\GroupSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class CreatePostController extends \Flarum\Api\Controller\AbstractCreateController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\PostSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['user', 'discussion', 'discussion.posts', 'discussion.lastPostedUser'];
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class CreateTokenController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @var BusDispatcher
         */
        protected $bus;
        /**
         * @var EventDispatcher
         */
        protected $events;
        /**
         * @param UserRepository $users
         * @param BusDispatcher $bus
         * @param EventDispatcher $events
         */
        public function __construct(\Flarum\User\UserRepository $users, \Illuminate\Contracts\Bus\Dispatcher $bus, \Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class CreateUserController extends \Flarum\Api\Controller\AbstractCreateController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\CurrentUserSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class DeleteAvatarController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\UserSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class DeleteDiscussionController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class DeleteFaviconController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Filesystem
         */
        protected $uploadDir;
        /**
         * @param SettingsRepositoryInterface $settings
         * @param Factory $filesystemFactory
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Filesystem\Factory $filesystemFactory)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class DeleteGroupController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class DeleteLogoController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Filesystem
         */
        protected $uploadDir;
        /**
         * @param SettingsRepositoryInterface $settings
         * @param Factory $filesystemFactory
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Filesystem\Factory $filesystemFactory)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class DeletePostController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class DeleteUserController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class ForgotPasswordController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param \Flarum\User\UserRepository $users
         * @param Dispatcher $bus
         */
        public function __construct(\Flarum\User\UserRepository $users, \Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ListDiscussionsController extends \Flarum\Api\Controller\AbstractListController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\DiscussionSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['user', 'lastPostedUser', 'mostRelevantPost', 'mostRelevantPost.user'];
        /**
         * {@inheritdoc}
         */
        public $optionalInclude = ['firstPost', 'lastPost'];
        /**
         * {@inheritDoc}
         */
        public $sort = ['lastPostedAt' => 'desc'];
        /**
         * {@inheritdoc}
         */
        public $sortFields = ['lastPostedAt', 'commentCount', 'createdAt'];
        /**
         * @var DiscussionFilterer
         */
        protected $filterer;
        /**
         * @var DiscussionSearcher
         */
        protected $searcher;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param DiscussionFilterer $filterer
         * @param DiscussionSearcher $searcher
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Discussion\Filter\DiscussionFilterer $filterer, \Flarum\Discussion\Search\DiscussionSearcher $searcher, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ListGroupsController extends \Flarum\Api\Controller\AbstractListController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\GroupSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $sortFields = ['nameSingular', 'namePlural', 'isHidden'];
        /**
         * {@inheritdoc}
         *
         * @var int
         */
        public $limit = -1;
        /**
         * @var GroupFilterer
         */
        protected $filterer;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param GroupFilterer $filterer
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Group\Filter\GroupFilterer $filterer, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ListNotificationsController extends \Flarum\Api\Controller\AbstractListController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\NotificationSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['fromUser', 'subject', 'subject.discussion'];
        /**
         * {@inheritdoc}
         */
        public $limit = 10;
        /**
         * @var NotificationRepository
         */
        protected $notifications;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param NotificationRepository $notifications
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Notification\NotificationRepository $notifications, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
        /**
         * @param \Flarum\Notification\Notification[] $notifications
         */
        private function loadSubjectDiscussions(array $notifications)
        {
        }
    }
    class ListPostsController extends \Flarum\Api\Controller\AbstractListController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\PostSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['user', 'user.groups', 'editedUser', 'hiddenUser', 'discussion'];
        /**
         * {@inheritdoc}
         */
        public $sortFields = ['createdAt'];
        /**
         * @var PostFilterer
         */
        protected $filterer;
        /**
         * @var PostRepository
         */
        protected $posts;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param PostFilterer $filterer
         * @param PostRepository $posts
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Post\Filter\PostFilterer $filterer, \Flarum\Post\PostRepository $posts, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function extractOffset(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class ListUsersController extends \Flarum\Api\Controller\AbstractListController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\UserSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['groups'];
        /**
         * {@inheritdoc}
         */
        public $sortFields = ['username', 'commentCount', 'discussionCount', 'lastSeenAt', 'joinedAt'];
        /**
         * @var UserFilterer
         */
        protected $filterer;
        /**
         * @var UserSearcher
         */
        protected $searcher;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param UserFilterer $filterer
         * @param UserSearcher $searcher
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\User\Filter\UserFilterer $filterer, \Flarum\User\Search\UserSearcher $searcher, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ReadAllNotificationsController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
}
namespace Flarum\User {
    trait AccountActivationMailerTrait
    {
        /**
         * @param User $user
         * @param string $email
         * @return EmailToken
         */
        protected function generateToken(\Flarum\User\User $user, $email)
        {
        }
        /**
         * Get the data that should be made available to email templates.
         *
         * @param User $user
         * @param EmailToken $token
         * @return array
         */
        protected function getEmailData(\Flarum\User\User $user, \Flarum\User\EmailToken $token)
        {
        }
        /**
         * @param User $user
         * @param array $data
         */
        protected function sendConfirmationEmail(\Flarum\User\User $user, $data)
        {
        }
    }
}
namespace Flarum\Api\Controller {
    class SendConfirmationEmailController implements \Psr\Http\Server\RequestHandlerInterface
    {
        use \Flarum\User\AccountActivationMailerTrait;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Queue
         */
        protected $queue;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param \Flarum\Settings\SettingsRepositoryInterface $settings
         * @param Queue $queue
         * @param UrlGenerator $url
         * @param TranslatorInterface $translator
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Queue\Queue $queue, \Flarum\Http\UrlGenerator $url, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class SendTestMailController implements \Psr\Http\Server\RequestHandlerInterface
    {
        protected $mailer;
        protected $translator;
        public function __construct(\Illuminate\Contracts\Mail\Mailer $mailer, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class SetPermissionController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class SetSettingsController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var \Flarum\Settings\SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Dispatcher
         */
        protected $dispatcher;
        /**
         * @param SettingsRepositoryInterface $settings
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Events\Dispatcher $dispatcher)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ShowDiscussionController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * @var \Flarum\Discussion\DiscussionRepository
         */
        protected $discussions;
        /**
         * @var PostRepository
         */
        protected $posts;
        /**
         * @var SlugManager
         */
        protected $slugManager;
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\DiscussionSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['posts', 'posts.discussion', 'posts.user', 'posts.user.groups', 'posts.editedUser', 'posts.hiddenUser'];
        /**
         * {@inheritdoc}
         */
        public $optionalInclude = ['user', 'lastPostedUser', 'firstPost', 'lastPost'];
        /**
         * @param \Flarum\Discussion\DiscussionRepository $discussions
         * @param \Flarum\Post\PostRepository $posts
         * @param \Flarum\Http\SlugManager $slugManager
         */
        public function __construct(\Flarum\Discussion\DiscussionRepository $discussions, \Flarum\Post\PostRepository $posts, \Flarum\Http\SlugManager $slugManager)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
        /**
         * @param Discussion $discussion
         * @param ServerRequestInterface $request
         * @param array $include
         */
        private function includePosts(\Flarum\Discussion\Discussion $discussion, \Psr\Http\Message\ServerRequestInterface $request, array $include)
        {
        }
        /**
         * @param Discussion $discussion
         * @param User $actor
         * @return array
         */
        private function loadPostIds(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor)
        {
        }
        /**
         * @param array $include
         * @return array
         */
        private function getPostRelationships(array $include)
        {
        }
        /**
         * @param ServerRequestInterface $request
         * @param Discussion$discussion
         * @param int $limit
         * @return int
         */
        private function getPostsOffset(\Psr\Http\Message\ServerRequestInterface $request, \Flarum\Discussion\Discussion $discussion, $limit)
        {
        }
        /**
         * @param Discussion $discussion
         * @param User $actor
         * @param int $offset
         * @param int $limit
         * @param array $include
         * @return mixed
         */
        private function loadPosts($discussion, $actor, $offset, $limit, array $include)
        {
        }
        protected function getRelationsToLoad() : array
        {
        }
    }
    class ShowExtensionReadmeController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\ExtensionReadmeSerializer::class;
        public function __construct(\Flarum\Extension\ExtensionManager $extensions)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ShowForumController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\ForumSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['groups'];
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ShowGroupController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * @var GroupRepository
         */
        protected $groups;
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\GroupSerializer::class;
        /**
         * @param \Flarum\Group\GroupRepository $groups
         */
        public function __construct(\Flarum\Group\GroupRepository $groups)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ShowMailSettingsController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\MailSettingsSerializer::class;
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ShowPostController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\PostSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['user', 'user.groups', 'editedUser', 'hiddenUser', 'discussion'];
        /**
         * @var \Flarum\Post\PostRepository
         */
        protected $posts;
        /**
         * @param \Flarum\Post\PostRepository $posts
         */
        public function __construct(\Flarum\Post\PostRepository $posts)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class ShowUserController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\UserSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['groups'];
        /**
         * @var SlugManager
         */
        protected $slugManager;
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @param SlugManager $slugManager
         * @param UserRepository $users
         */
        public function __construct(\Flarum\Http\SlugManager $slugManager, \Flarum\User\UserRepository $users)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UninstallExtensionController extends \Flarum\Api\Controller\AbstractDeleteController
    {
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        /**
         * @param \Flarum\Extension\ExtensionManager $extensions
         */
        public function __construct(\Flarum\Extension\ExtensionManager $extensions)
        {
        }
        protected function delete(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class UpdateDiscussionController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\DiscussionSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UpdateExtensionController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        public function __construct(\Flarum\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class UpdateGroupController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\GroupSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UpdateNotificationController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\NotificationSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UpdatePostController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\PostSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['editedUser', 'discussion'];
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UpdateUserController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\UserSerializer::class;
        /**
         * {@inheritdoc}
         */
        public $include = ['groups'];
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    class UploadAvatarController extends \Flarum\Api\Controller\AbstractShowController
    {
        /**
         * {@inheritdoc}
         */
        public $serializer = \Flarum\Api\Serializer\UserSerializer::class;
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @param Dispatcher $bus
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
    }
    abstract class UploadImageController extends \Flarum\Api\Controller\ShowForumController
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Filesystem
         */
        protected $uploadDir;
        /**
         * @var string
         */
        protected $fileExtension = 'png';
        /**
         * @var string
         */
        protected $filePathSettingKey = '';
        /**
         * @var string
         */
        protected $filenamePrefix = '';
        /**
         * @param SettingsRepositoryInterface $settings
         * @param Factory $filesystemFactory
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Filesystem\Factory $filesystemFactory)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function data(\Psr\Http\Message\ServerRequestInterface $request, \Tobscure\JsonApi\Document $document)
        {
        }
        /**
         * @param UploadedFileInterface $file
         * @return Image
         */
        protected abstract function makeImage(\Psr\Http\Message\UploadedFileInterface $file) : \Intervention\Image\Image;
    }
    class UploadFaviconController extends \Flarum\Api\Controller\UploadImageController
    {
        protected $filePathSettingKey = 'favicon_path';
        protected $filenamePrefix = 'favicon';
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param SettingsRepositoryInterface $settings
         * @param Factory $filesystemFactory
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Filesystem\Factory $filesystemFactory, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function makeImage(\Psr\Http\Message\UploadedFileInterface $file) : \Intervention\Image\Image
        {
        }
    }
    class UploadLogoController extends \Flarum\Api\Controller\UploadImageController
    {
        protected $filePathSettingKey = 'logo_path';
        protected $filenamePrefix = 'logo';
        /**
         * {@inheritdoc}
         */
        protected function makeImage(\Psr\Http\Message\UploadedFileInterface $file) : \Intervention\Image\Image
        {
        }
    }
}
namespace Flarum\Foundation {
    /**
     * An exception that has a well-known meaning in a Flarum application.
     *
     * We use these exceptions as a mechanism to quickly bubble up errors from the
     * domain layer. Using the {@see \Flarum\Foundation\ErrorHandling\Registry},
     * these will then be mapped to error "types" and, if relevant, HTTP statuses.
     *
     * Exceptions implementing this interface can implement their own logic to
     * determine their own type (usually a hardcoded value).
     */
    interface KnownError
    {
        /**
         * Determine the exception's type.
         *
         * This should be a short, precise identifier for the error that can be
         * exposed to users as an error code. Furthermore, it can be used to find
         * appropriate error messages in translations or views to render pretty
         * error pages.
         *
         * Different exception classes are allowed to return the same status code,
         * e.g. when they have similar semantic meaning to the end user, but are
         * thrown by different subsystems.
         *
         * @return string
         */
        public function getType() : string;
    }
}
namespace Flarum\Api\Exception {
    class InvalidAccessTokenException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
}
namespace Flarum\Api {
    class JsonApiResponse extends \Laminas\Diactoros\Response\JsonResponse
    {
        /**
         * {@inheritdoc}
         */
        public function __construct(\Tobscure\JsonApi\Document $document, $status = 200, array $headers = [], $encodingOptions = 15)
        {
        }
    }
}
namespace Flarum\Api\Middleware {
    class FakeHttpMethods implements \Psr\Http\Server\MiddlewareInterface
    {
        const HEADER_NAME = 'x-http-method-override';
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ThrottleApi implements \Psr\Http\Server\MiddlewareInterface
    {
        protected $throttlers;
        public function __construct(array $throttlers)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * @return bool
         */
        public function throttle(\Psr\Http\Message\ServerRequestInterface $request) : bool
        {
        }
    }
}
namespace Flarum\Api\Serializer {
    abstract class AbstractSerializer extends \Tobscure\JsonApi\AbstractSerializer
    {
        /**
         * @var Request
         */
        protected $request;
        /**
         * @var User
         */
        protected $actor;
        /**
         * @var Container
         */
        protected static $container;
        /**
         * @var callable[]
         */
        protected static $attributeMutators = [];
        /**
         * @var array
         */
        protected static $customRelations = [];
        /**
         * @return Request
         */
        public function getRequest()
        {
        }
        /**
         * @param Request $request
         */
        public function setRequest(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @return User
         */
        public function getActor()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getAttributes($model, array $fields = null)
        {
        }
        /**
         * Get the default set of serialized attributes for a model.
         *
         * @param object|array $model
         * @return array
         */
        protected abstract function getDefaultAttributes($model);
        /**
         * @param DateTime|null $date
         * @return string|null
         */
        public function formatDate(\DateTime $date = null)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getRelationship($model, $name)
        {
        }
        /**
         * Get a custom relationship.
         *
         * @param mixed $model
         * @param string $name
         * @return Relationship|null
         */
        protected function getCustomRelationship($model, $name)
        {
        }
        /**
         * Get a relationship builder for a has-one relationship.
         *
         * @param mixed $model
         * @param string|Closure|\Tobscure\JsonApi\SerializerInterface $serializer
         * @param string|Closure|null $relation
         * @return Relationship
         */
        public function hasOne($model, $serializer, $relation = null)
        {
        }
        /**
         * Get a relationship builder for a has-many relationship.
         *
         * @param mixed $model
         * @param string|Closure|\Tobscure\JsonApi\SerializerInterface $serializer
         * @param string|null $relation
         * @return Relationship
         */
        public function hasMany($model, $serializer, $relation = null)
        {
        }
        /**
         * @param mixed $model
         * @param string|Closure|\Tobscure\JsonApi\SerializerInterface $serializer
         * @param string|null $relation
         * @param bool $many
         * @return Relationship
         */
        protected function buildRelationship($model, $serializer, $relation = null, $many = false)
        {
        }
        /**
         * @param mixed $model
         * @param string $relation
         * @return mixed
         */
        protected function getRelationshipData($model, $relation)
        {
        }
        /**
         * @param mixed $serializer
         * @param mixed $model
         * @param mixed $data
         * @return SerializerInterface
         * @throws InvalidArgumentException
         */
        protected function resolveSerializer($serializer, $model, $data)
        {
        }
        /**
         * @param string $class
         * @return object
         */
        protected function resolveSerializerClass($class)
        {
        }
        /**
         * @return Container
         */
        public static function getContainer()
        {
        }
        /**
         * @param Container $container
         *
         * @internal
         */
        public static function setContainer(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * @param string $serializerClass
         * @param callable $callback
         *
         * @internal
         */
        public static function addAttributeMutator(string $serializerClass, callable $callback) : void
        {
        }
        /**
         * @param string $serializerClass
         * @param string $relation
         * @param callable $callback
         *
         * @internal
         */
        public static function setRelationship(string $serializerClass, string $relation, callable $callback) : void
        {
        }
    }
    class BasicDiscussionSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'discussions';
        /**
         * @var SlugManager
         */
        protected $slugManager;
        public function __construct(\Flarum\Http\SlugManager $slugManager)
        {
        }
        /**
         * {@inheritdoc}
         *
         * @param Discussion $discussion
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function user($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function firstPost($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function lastPostedUser($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function lastPost($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function posts($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function mostRelevantPost($discussion)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function hiddenUser($discussion)
        {
        }
    }
    class BasicPostSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * @var LogReporter
         */
        protected $log;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        public function __construct(\Flarum\Foundation\ErrorHandling\LogReporter $log, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected $type = 'posts';
        /**
         * {@inheritdoc}
         *
         * @param \Flarum\Post\Post $post
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function user($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function discussion($post)
        {
        }
    }
    class BasicUserSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'users';
        /**
         * @var SlugManager
         */
        protected $slugManager;
        public function __construct(\Flarum\Http\SlugManager $slugManager)
        {
        }
        /**
         * {@inheritdoc}
         *
         * @param User $user
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($user)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function groups($user)
        {
        }
    }
    class UserSerializer extends \Flarum\Api\Serializer\BasicUserSerializer
    {
        /**
         * @param \Flarum\User\User $user
         * @return array
         */
        protected function getDefaultAttributes($user)
        {
        }
    }
    class CurrentUserSerializer extends \Flarum\Api\Serializer\UserSerializer
    {
        /**
         * @param \Flarum\User\User $user
         * @return array
         */
        protected function getDefaultAttributes($user)
        {
        }
    }
    class DiscussionSerializer extends \Flarum\Api\Serializer\BasicDiscussionSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected function getDefaultAttributes($discussion)
        {
        }
    }
    class ExtensionReadmeSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected function getDefaultAttributes($extension)
        {
        }
        public function getId($extension)
        {
        }
        public function getType($extension)
        {
        }
    }
    class ForumSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'forums';
        /**
         * @var Config
         */
        protected $config;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var Cloud
         */
        protected $assetsFilesystem;
        /**
         * @param Config $config
         * @param Factory $filesystemFactory
         * @param SettingsRepositoryInterface $settings
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Foundation\Config $config, \Illuminate\Contracts\Filesystem\Factory $filesystemFactory, \Flarum\Settings\SettingsRepositoryInterface $settings, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getId($model)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function getDefaultAttributes($model)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function groups($model)
        {
        }
        /**
         * @return null|string
         */
        protected function getLogoUrl()
        {
        }
        /**
         * @return null|string
         */
        protected function getFaviconUrl()
        {
        }
        public function getAssetUrl($assetPath) : string
        {
        }
    }
    class GroupSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'groups';
        /**
         * @var TranslatorInterface
         */
        private $translator;
        /**
         * @param TranslatorInterface $translator
         */
        public function __construct(\Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * {@inheritdoc}
         *
         * @param Group $group
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($group)
        {
        }
        /**
         * @param string $name
         * @return string
         */
        private function translateGroupName($name)
        {
        }
    }
    class MailSettingsSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'mail-settings';
        /**
         * {@inheritdoc}
         *
         * @param array $settings
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($settings)
        {
        }
        private function serializeDriver(\Flarum\Mail\DriverInterface $driver)
        {
        }
        public function getId($model)
        {
        }
    }
    class NotificationSerializer extends \Flarum\Api\Serializer\AbstractSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected $type = 'notifications';
        /**
         * A map of notification types (key) to the serializer that should be used
         * to output the notification's subject (value).
         *
         * @var array
         */
        protected static $subjectSerializers = [];
        /**
         * {@inheritdoc}
         *
         * @param \Flarum\Notification\Notification $notification
         * @throws InvalidArgumentException
         */
        protected function getDefaultAttributes($notification)
        {
        }
        /**
         * @param Notification $notification
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function user($notification)
        {
        }
        /**
         * @param Notification $notification
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function fromUser($notification)
        {
        }
        /**
         * @param Notification $notification
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function subject($notification)
        {
        }
        /**
         * @param $type
         * @param $serializer
         */
        public static function setSubjectSerializer($type, $serializer)
        {
        }
    }
    class PostSerializer extends \Flarum\Api\Serializer\BasicPostSerializer
    {
        /**
         * {@inheritdoc}
         */
        protected function getDefaultAttributes($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function user($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function discussion($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function editedUser($post)
        {
        }
        /**
         * @return \Tobscure\JsonApi\Relationship
         */
        protected function hiddenUser($post)
        {
        }
    }
}
namespace Flarum\Bus {
    class BusServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        public function register()
        {
        }
    }
    class Dispatcher extends \Illuminate\Bus\Dispatcher
    {
        public function getCommandHandler($command)
        {
        }
    }
}
namespace Flarum\Console {
    abstract class AbstractCommand extends \Symfony\Component\Console\Command\Command
    {
        /**
         * @var InputInterface
         */
        protected $input;
        /**
         * @var OutputInterface
         */
        protected $output;
        /**
         * {@inheritdoc}
         */
        protected function execute(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
         * Fire the command.
         */
        protected abstract function fire();
        /**
         * Did the user pass the given option?
         *
         * @param string $name
         * @return bool
         */
        protected function hasOption($name)
        {
        }
        /**
         * Send an info message to the user.
         *
         * @param string $message
         */
        protected function info($message)
        {
        }
        /**
         * Send an error or warning message to the user.
         *
         * If possible, this will send the message via STDERR.
         *
         * @param string $message
         */
        protected function error($message)
        {
        }
    }
}
namespace Flarum\Console\Cache {
    class Factory implements \Illuminate\Contracts\Cache\Factory
    {
        /**
         * @var Container
         */
        private $container;
        public function __construct(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * Get a cache store instance by name.
         *
         * @param  string|null $name
         * @return Repository
         */
        public function store($name = null)
        {
        }
    }
}
namespace Flarum\Console {
    class ConsoleServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritDoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    class Schedule extends \Illuminate\Console\Scheduling\Schedule
    {
        public function dueEvents($container)
        {
        }
    }
    class Server
    {
        private $site;
        public function __construct(\Flarum\Foundation\SiteInterface $site)
        {
        }
        public function listen()
        {
        }
        private function handleErrors(\Symfony\Component\Console\Application $console)
        {
        }
    }
}
namespace Flarum\Database\Console {
    class GenerateDumpCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var Connection
         */
        protected $connection;
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @param Connection $connection
         * @param Paths $paths
         */
        public function __construct(\Illuminate\Database\Connection $connection, \Flarum\Foundation\Paths $paths)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
    }
    class MigrateCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var Container
         */
        protected $container;
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @param Container $container
         * @param Paths $paths
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Foundation\Paths $paths)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
        public function upgrade()
        {
        }
    }
    class ResetCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var ExtensionManager
         */
        protected $manager;
        /**
         * @param ExtensionManager $manager
         */
        public function __construct(\Flarum\Extension\ExtensionManager $manager)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
    }
}
namespace Flarum\Database {
    interface MigrationRepositoryInterface
    {
        /**
         * Get the ran migrations for the given extension.
         *
         * @param string $extension
         * @return array
         */
        public function getRan($extension = null);
        /**
         * Log that a migration was run.
         *
         * @param string $file
         * @param string $extension
         * @return void
         */
        public function log($file, $extension = null);
        /**
         * Remove a migration from the log.
         *
         * @param string $file
         * @param string $extension
         * @return void
         */
        public function delete($file, $extension = null);
        /**
         * Determine if the migration repository exists.
         *
         * @return bool
         */
        public function repositoryExists();
    }
    class DatabaseMigrationRepository implements \Flarum\Database\MigrationRepositoryInterface
    {
        /**
         * The name of the database connection to use.
         *
         * @var ConnectionInterface
         */
        protected $connection;
        /**
         * The name of the migration table.
         *
         * @var string
         */
        protected $table;
        /**
         * Create a new database migration repository instance.
         *
         * @param  \Illuminate\Database\ConnectionInterface $connection
         * @param  string                                   $table
         */
        public function __construct(\Illuminate\Database\ConnectionInterface $connection, $table)
        {
        }
        /**
         * Get the ran migrations.
         *
         * @param string $extension
         * @return array
         */
        public function getRan($extension = null)
        {
        }
        /**
         * Log that a migration was run.
         *
         * @param string $file
         * @param string $extension
         * @return void
         */
        public function log($file, $extension = null)
        {
        }
        /**
         * Remove a migration from the log.
         *
         * @param string $file
         * @param string $extension
         * @return void
         */
        public function delete($file, $extension = null)
        {
        }
        /**
         * Determine if the migration repository exists.
         *
         * @return bool
         */
        public function repositoryExists()
        {
        }
        /**
         * Get a query builder for the migration table.
         *
         * @return \Illuminate\Database\Query\Builder
         */
        protected function table()
        {
        }
    }
    class DatabaseServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    /**
     * Migration factory.
     *
     * Implements some handy shortcuts for creating typical migrations.
     */
    abstract class Migration
    {
        /**
         * Create a table.
         */
        public static function createTable($name, callable $definition)
        {
        }
        /**
         * Rename a table.
         */
        public static function renameTable($from, $to)
        {
        }
        /**
         * Add columns to a table.
         */
        public static function addColumns($tableName, array $columnDefinitions)
        {
        }
        /**
         * Drop columns from a table.
         */
        public static function dropColumns($tableName, array $columnDefinitions)
        {
        }
        /**
         * Rename a column.
         */
        public static function renameColumn($tableName, $from, $to)
        {
        }
        /**
         * Rename multiple columns.
         */
        public static function renameColumns($tableName, array $columnNames)
        {
        }
        /**
         * Add default values for config values.
         *
         * @deprecated Use the Settings extender's `default` method instead to register settings.
         * @see Settings::default()
         */
        public static function addSettings(array $defaults)
        {
        }
        /**
         * Add default permissions.
         */
        public static function addPermissions(array $permissions)
        {
        }
    }
    /**
     * @internal
     */
    class Migrator
    {
        /**
         * The migration repository implementation.
         *
         * @var \Flarum\Database\MigrationRepositoryInterface
         */
        protected $repository;
        /**
         * The filesystem instance.
         *
         * @var \Illuminate\Filesystem\Filesystem
         */
        protected $files;
        /**
         * The output interface implementation.
         *
         * @var OutputInterface
         */
        protected $output;
        /**
         * @var ConnectionInterface|MySqlConnection
         */
        protected $connection;
        /**
         * Create a new migrator instance.
         *
         * @param  MigrationRepositoryInterface  $repository
         * @param  ConnectionInterface           $connection
         * @param  Filesystem                    $files
         */
        public function __construct(\Flarum\Database\MigrationRepositoryInterface $repository, \Illuminate\Database\ConnectionInterface $connection, \Illuminate\Filesystem\Filesystem $files)
        {
        }
        /**
         * Run the outstanding migrations at a given path.
         *
         * @param  string    $path
         * @param  Extension $extension
         * @return void
         */
        public function run($path, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * Run an array of migrations.
         *
         * @param  string    $path
         * @param  array     $migrations
         * @param  Extension $extension
         * @return void
         */
        public function runMigrationList($path, $migrations, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * Run "up" a migration instance.
         *
         * @param  string    $path
         * @param  string    $file
         * @param  string    $path
         * @param  Extension $extension
         * @return void
         */
        protected function runUp($path, $file, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * Rolls all of the currently applied migrations back.
         *
         * @param  string    $path
         * @param  Extension $extension
         * @return int
         */
        public function reset($path, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * Run "down" a migration instance.
         *
         * @param  string    $path
         * @param  string    $file
         * @param  string    $path
         * @param  Extension $extension
         * @return void
         */
        protected function runDown($path, $file, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * Runs a closure migration based on the migrate direction.
         *
         * @param        $migration
         * @param string $direction
         * @throws Exception
         */
        protected function runClosureMigration($migration, $direction = 'up')
        {
        }
        /**
         * Get all of the migration files in a given path.
         *
         * @param  string $path
         * @return array
         */
        public function getMigrationFiles($path)
        {
        }
        /**
         * Resolve a migration instance from a file.
         *
         * @param string $path
         * @param string $file
         * @return array
         * @throws \Illuminate\Contracts\Filesystem\FileNotFoundException
         */
        public function resolve($path, $file)
        {
        }
        /**
         * Initialize the Flarum database from a schema dump.
         *
         * @param string $path to the directory containing the dump.
         */
        public function installFromSchema(string $path)
        {
        }
        /**
         * Set the output implementation that should be used by the console.
         *
         * @param OutputInterface $output
         * @return $this
         */
        public function setOutput(\Symfony\Component\Console\Output\OutputInterface $output)
        {
        }
        /**
         * Write a note to the conosle's output.
         *
         * @param string $message
         * @return void
         */
        protected function note($message)
        {
        }
        /**
         * Determine if the migration repository exists.
         *
         * @return bool
         */
        public function repositoryExists()
        {
        }
    }
    trait ScopeVisibilityTrait
    {
        protected static $visibilityScopers = [];
        public static function registerVisibilityScoper($scoper, $ability = null)
        {
        }
        /**
         * Scope a query to only include records that are visible to a user.
         *
         * @param Builder $query
         * @param User $actor
         */
        public function scopeWhereVisibleTo(\Illuminate\Database\Eloquent\Builder $query, \Flarum\User\User $actor, string $ability = 'view')
        {
        }
    }
}
namespace Flarum\User\Access {
    abstract class AbstractPolicy
    {
        public const GLOBAL = 'GLOBAL';
        public const ALLOW = 'ALLOW';
        public const DENY = 'DENY';
        public const FORCE_ALLOW = 'FORCE_ALLOW';
        public const FORCE_DENY = 'FORCE_DENY';
        protected function allow()
        {
        }
        protected function deny()
        {
        }
        protected function forceAllow()
        {
        }
        protected function forceDeny()
        {
        }
        /**
         * @param User $user
         * @param string $ability
         * @param $instance
         * @return string|void
         */
        public function checkAbility(\Flarum\User\User $actor, string $ability, $instance)
        {
        }
        /**
         * Allows `true` to be used in place of `->allow()`, and `false` instead of `->deny()`
         * This allows more concise and intuitive code, by returning boolean statements:.
         *
         * WITHOUT THIS:
         * `return SOME_BOOLEAN_LOGIC ? $this->allow() : $this->deny();
         *
         * WITH THIS:
         * `return SOME_BOOLEAN_LOGIC;
         *
         * @param mixed $result
         * @return string|void
         */
        public function sanitizeResult($result)
        {
        }
    }
}
namespace Flarum\Discussion\Access {
    class DiscussionPolicy extends \Flarum\User\Access\AbstractPolicy
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @param SettingsRepositoryInterface $settings
         * @param Dispatcher $events
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings)
        {
        }
        /**
         * @param User $actor
         * @param string $ability
         * @return bool|null
         */
        public function can(\Flarum\User\User $actor, $ability)
        {
        }
        /**
         * @param User $actor
         * @param \Flarum\Discussion\Discussion $discussion
         * @return bool|null
         */
        public function rename(\Flarum\User\User $actor, \Flarum\Discussion\Discussion $discussion)
        {
        }
        /**
         * @param User $actor
         * @param \Flarum\Discussion\Discussion $discussion
         * @return bool|null
         */
        public function hide(\Flarum\User\User $actor, \Flarum\Discussion\Discussion $discussion)
        {
        }
    }
    class ScopeDiscussionVisibility
    {
        /**
         * @param User $actor
         * @param Builder $query
         */
        public function __invoke(\Flarum\User\User $actor, $query)
        {
        }
    }
}
namespace Flarum\Discussion\Command {
    class DeleteDiscussion
    {
        /**
         * The ID of the discussion to delete.
         *
         * @var int
         */
        public $discussionId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any other user input associated with the action. This is unused by
         * default, but may be used by extensions.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $discussionId The ID of the discussion to delete.
         * @param User $actor The user performing the action.
         * @param array $data Any other user input associated with the action. This
         *     is unused by default, but may be used by extensions.
         */
        public function __construct($discussionId, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
}
namespace Flarum\Foundation {
    trait DispatchEventsTrait
    {
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * Dispatch all events for an entity.
         *
         * @param object $entity
         * @param User $actor
         */
        public function dispatchEventsFor($entity, \Flarum\User\User $actor = null)
        {
        }
    }
}
namespace Flarum\Discussion\Command {
    class DeleteDiscussionHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\Discussion\DiscussionRepository
         */
        protected $discussions;
        /**
         * @param Dispatcher $events
         * @param DiscussionRepository $discussions
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Discussion\DiscussionRepository $discussions)
        {
        }
        /**
         * @param DeleteDiscussion $command
         * @return \Flarum\Discussion\Discussion
         * @throws PermissionDeniedException
         */
        public function handle(\Flarum\Discussion\Command\DeleteDiscussion $command)
        {
        }
    }
    class EditDiscussion
    {
        /**
         * The ID of the discussion to edit.
         *
         * @var int
         */
        public $discussionId;
        /**
         * The user performing the action.
         *
         * @var \Flarum\User\User
         */
        public $actor;
        /**
         * The attributes to update on the discussion.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $discussionId The ID of the discussion to edit.
         * @param \Flarum\User\User $actor The user performing the action.
         * @param array $data The attributes to update on the discussion.
         */
        public function __construct($discussionId, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class EditDiscussionHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        /**
         * @var DiscussionValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param DiscussionRepository $discussions
         * @param DiscussionValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Discussion\DiscussionRepository $discussions, \Flarum\Discussion\DiscussionValidator $validator)
        {
        }
        /**
         * @param EditDiscussion $command
         * @return \Flarum\Discussion\Discussion
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Discussion\Command\EditDiscussion $command)
        {
        }
    }
    class ReadDiscussion
    {
        /**
         * The ID of the discussion to mark as read.
         *
         * @var int
         */
        public $discussionId;
        /**
         * The user to mark the discussion as read for.
         *
         * @var User
         */
        public $actor;
        /**
         * The number of the post to mark as read.
         *
         * @var int
         */
        public $lastReadPostNumber;
        /**
         * @param int $discussionId The ID of the discussion to mark as read.
         * @param User $actor The user to mark the discussion as read for.
         * @param int $lastReadPostNumber The number of the post to mark as read.
         */
        public function __construct($discussionId, \Flarum\User\User $actor, $lastReadPostNumber)
        {
        }
    }
    class ReadDiscussionHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        /**
         * @param Dispatcher $events
         * @param DiscussionRepository $discussions
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Discussion\DiscussionRepository $discussions)
        {
        }
        /**
         * @param ReadDiscussion $command
         * @return \Flarum\Discussion\UserState
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Discussion\Command\ReadDiscussion $command)
        {
        }
    }
    class StartDiscussion
    {
        /**
         * The user authoring the discussion.
         *
         * @var User
         */
        public $actor;
        /**
         * The discussion attributes.
         *
         * @var array
         */
        public $data;
        /**
         * The current ip address of the actor.
         *
         * @var string
         */
        public $ipAddress;
        /**
         * @param User   $actor The user authoring the discussion.
         * @param array  $data  The discussion attributes.
         * @param string $ipAddress The current ip address of the actor.
         */
        public function __construct(\Flarum\User\User $actor, array $data, string $ipAddress)
        {
        }
    }
    class StartDiscussionHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var BusDispatcher
         */
        protected $bus;
        /**
         * @var \Flarum\Discussion\DiscussionValidator
         */
        protected $validator;
        /**
         * @param EventDispatcher $events
         * @param BusDispatcher $bus
         * @param \Flarum\Discussion\DiscussionValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Illuminate\Contracts\Bus\Dispatcher $bus, \Flarum\Discussion\DiscussionValidator $validator)
        {
        }
        /**
         * @param StartDiscussion $command
         * @return mixed
         * @throws Exception
         */
        public function handle(\Flarum\Discussion\Command\StartDiscussion $command)
        {
        }
    }
}
namespace Flarum\Foundation {
    trait EventGeneratorTrait
    {
        /**
         * @var array
         */
        protected $pendingEvents = [];
        /**
         * Raise a new event.
         *
         * @param mixed $event
         */
        public function raise($event)
        {
        }
        /**
         * Return and reset all pending events.
         *
         * @return array
         */
        public function releaseEvents()
        {
        }
    }
}
namespace Flarum\Discussion {
    /**
     * @property int $id
     * @property string $title
     * @property string $slug
     * @property int $comment_count
     * @property int $participant_count
     * @property int $post_number_index
     * @property \Carbon\Carbon $created_at
     * @property int|null $user_id
     * @property int|null $first_post_id
     * @property \Carbon\Carbon|null $last_posted_at
     * @property int|null $last_posted_user_id
     * @property int|null $last_post_id
     * @property int|null $last_post_number
     * @property \Carbon\Carbon|null $hidden_at
     * @property int|null $hidden_user_id
     * @property UserState|null $state
     * @property \Illuminate\Database\Eloquent\Collection $posts
     * @property \Illuminate\Database\Eloquent\Collection $comments
     * @property \Illuminate\Database\Eloquent\Collection $participants
     * @property Post|null $firstPost
     * @property User|null $user
     * @property Post|null $lastPost
     * @property User|null $lastPostedUser
     * @property \Illuminate\Database\Eloquent\Collection $readers
     * @property bool $is_private
     */
    class Discussion extends \Flarum\Database\AbstractModel
    {
        use \Flarum\Foundation\EventGeneratorTrait;
        use \Flarum\Database\ScopeVisibilityTrait;
        /**
         * An array of posts that have been modified during this request.
         *
         * @var array
         */
        protected $modifiedPosts = [];
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at', 'last_posted_at', 'hidden_at'];
        /**
         * The attributes that should be cast to native types.
         *
         * @var array
         */
        protected $casts = ['is_private' => 'boolean'];
        /**
         * The user for which the state relationship should be loaded.
         *
         * @var User
         */
        protected static $stateUser;
        /**
         * Boot the model.
         *
         * @return void
         */
        public static function boot()
        {
        }
        /**
         * Start a new discussion. Raises the DiscussionWasStarted event.
         *
         * @param string $title
         * @param User $user
         * @return static
         */
        public static function start($title, \Flarum\User\User $user)
        {
        }
        /**
         * Rename the discussion. Raises the DiscussionWasRenamed event.
         *
         * @param string $title
         * @return $this
         */
        public function rename($title)
        {
        }
        /**
         * Hide the discussion.
         *
         * @param User $actor
         * @return $this
         */
        public function hide(\Flarum\User\User $actor = null)
        {
        }
        /**
         * Restore the discussion.
         *
         * @return $this
         */
        public function restore()
        {
        }
        /**
         * Set the discussion's first post details.
         *
         * @param Post $post
         * @return $this
         */
        public function setFirstPost(\Flarum\Post\Post $post)
        {
        }
        /**
         * Set the discussion's last post details.
         *
         * @param Post $post
         * @return $this
         */
        public function setLastPost(\Flarum\Post\Post $post)
        {
        }
        /**
         * Refresh a discussion's last post details.
         *
         * @return $this
         */
        public function refreshLastPost()
        {
        }
        /**
         * Refresh the discussion's comment count.
         *
         * @return $this
         */
        public function refreshCommentCount()
        {
        }
        /**
         * Refresh the discussion's participant count.
         *
         * @return $this
         */
        public function refreshParticipantCount()
        {
        }
        /**
         * Save a post, attempting to merge it with the discussion's last post.
         *
         * The merge logic is delegated to the new post. (As an example, a
         * DiscussionRenamedPost will merge if adjacent to another
         * DiscussionRenamedPost, and delete if the title has been reverted
         * completely.)
         *
         * @param \Flarum\Post\MergeableInterface $post The post to save.
         * @return Post The resulting post. It may or may not be the same post as
         *     was originally intended to be saved. It also may not exist, if the
         *     merge logic resulted in deletion.
         */
        public function mergePost(\Flarum\Post\MergeableInterface $post)
        {
        }
        /**
         * Get the posts that have been modified during this request.
         *
         * @return array
         */
        public function getModifiedPosts()
        {
        }
        /**
         * Define the relationship with the discussion's posts.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function posts()
        {
        }
        /**
         * Define the relationship with the discussion's publicly-visible comments.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function comments()
        {
        }
        /**
         * Query the discussion's participants (a list of unique users who have
         * posted in the discussion).
         *
         * @return \Illuminate\Database\Eloquent\Builder
         */
        public function participants()
        {
        }
        /**
         * Define the relationship with the discussion's first post.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function firstPost()
        {
        }
        /**
         * Define the relationship with the discussion's author.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Define the relationship with the discussion's last post.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function lastPost()
        {
        }
        /**
         * Define the relationship with the discussion's most recent author.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function lastPostedUser()
        {
        }
        /**
         * Define the relationship with the discussion's most relevant post.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function mostRelevantPost()
        {
        }
        /**
         * Define the relationship with the discussion's readers.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
         */
        public function readers()
        {
        }
        /**
         * Define the relationship with the discussion's state for a particular
         * user.
         *
         * If no user is passed (i.e. in the case of eager loading the 'state'
         * relation), then the static `$stateUser` property is used.
         *
         * @see Discussion::setStateUser()
         *
         * @param User|null $user
         * @return \Illuminate\Database\Eloquent\Relations\HasOne
         */
        public function state(\Flarum\User\User $user = null)
        {
        }
        /**
         * Get the state model for a user, or instantiate a new one if it does not
         * exist.
         *
         * @param User $user
         * @return \Flarum\Discussion\UserState
         */
        public function stateFor(\Flarum\User\User $user)
        {
        }
        /**
         * Set the user for which the state relationship should be loaded.
         *
         * @param User $user
         */
        public static function setStateUser(\Flarum\User\User $user)
        {
        }
        /**
         * Set the discussion title.
         *
         * This automatically creates a matching slug for the discussion.
         *
         * @param string $title
         */
        protected function setTitleAttribute($title)
        {
        }
    }
    class DiscussionMetadataUpdater
    {
        public function subscribe(\Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
        public function whenPostWasPosted(\Flarum\Post\Event\Posted $event)
        {
        }
        public function whenPostWasDeleted(\Flarum\Post\Event\Deleted $event)
        {
        }
        public function whenPostWasHidden(\Flarum\Post\Event\Hidden $event)
        {
        }
        public function whenPostWasRestored(\Flarum\Post\Event\Restored $event)
        {
        }
        protected function removePost(\Flarum\Post\Post $post)
        {
        }
    }
    class DiscussionRenamedLogger
    {
        /**
         * @var NotificationSyncer
         */
        protected $notifications;
        public function __construct(\Flarum\Notification\NotificationSyncer $notifications)
        {
        }
        public function handle(\Flarum\Discussion\Event\Renamed $event)
        {
        }
    }
    class DiscussionRepository
    {
        /**
         * Get a new query builder for the discussions table.
         *
         * @return Builder
         */
        public function query()
        {
        }
        /**
         * Find a discussion by ID, optionally making sure it is visible to a
         * certain user, or throw an exception.
         *
         * @param int $id
         * @param User $user
         * @return \Flarum\Discussion\Discussion
         */
        public function findOrFail($id, \Flarum\User\User $user = null)
        {
        }
        /**
         * Get the IDs of discussions which a user has read completely.
         *
         * @param User $user
         * @return array
         */
        public function getReadIds(\Flarum\User\User $user)
        {
        }
        /**
         * Scope a query to only include records that are visible to a user.
         *
         * @param Builder $query
         * @param User $user
         * @return Builder
         */
        protected function scopeVisibleTo(\Illuminate\Database\Eloquent\Builder $query, \Flarum\User\User $user = null)
        {
        }
    }
    class DiscussionServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        public function boot(\Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
    }
}
namespace Flarum\Foundation {
    abstract class AbstractValidator
    {
        /**
         * @var array
         */
        protected $configuration = [];
        public function addConfiguration($callable)
        {
        }
        /**
         * @var array
         */
        protected $rules = [];
        /**
         * @var Factory
         */
        protected $validator;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param Factory $validator
         * @param TranslatorInterface $translator
         */
        public function __construct(\Illuminate\Validation\Factory $validator, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * Throw an exception if a model is not valid.
         *
         * @param array $attributes
         */
        public function assertValid(array $attributes)
        {
        }
        /**
         * @return array
         */
        protected function getRules()
        {
        }
        /**
         * @return array
         */
        protected function getMessages()
        {
        }
        /**
         * Make a new validator instance for this model.
         *
         * @param array $attributes
         * @return \Illuminate\Validation\Validator
         */
        protected function makeValidator(array $attributes)
        {
        }
    }
}
namespace Flarum\Discussion {
    class DiscussionValidator extends \Flarum\Foundation\AbstractValidator
    {
        protected $rules = ['title' => ['required', 'min:3', 'max:80']];
    }
}
namespace Flarum\Discussion\Event {
    class Deleted
    {
        /**
         * @var \Flarum\Discussion\Discussion
         */
        public $discussion;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor = null)
        {
        }
    }
    class Deleting
    {
        /**
         * The discussion that is going to be deleted.
         *
         * @var Discussion
         */
        public $discussion;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any user input associated with the command.
         *
         * @var array
         */
        public $data;
        /**
         * @param Discussion $discussion
         * @param User $actor
         * @param array $data
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
    class Hidden
    {
        /**
         * @var \Flarum\Discussion\Discussion
         */
        public $discussion;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor = null)
        {
        }
    }
    class Renamed
    {
        /**
         * @var Discussion
         */
        public $discussion;
        /**
         * @var string
         */
        public $oldTitle;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         * @param string $oldTitle
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, $oldTitle, \Flarum\User\User $actor = null)
        {
        }
    }
    class Restored
    {
        /**
         * @var \Flarum\Discussion\Discussion
         */
        public $discussion;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor = null)
        {
        }
    }
    class Saving
    {
        /**
         * The discussion that will be saved.
         *
         * @var \Flarum\Discussion\Discussion
         */
        public $discussion;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any user input associated with the command.
         *
         * @var array
         */
        public $data;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         * @param array $data
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
    class Started
    {
        /**
         * @var \Flarum\Discussion\Discussion
         */
        public $discussion;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Discussion\Discussion $discussion
         * @param User $actor
         */
        public function __construct(\Flarum\Discussion\Discussion $discussion, \Flarum\User\User $actor = null)
        {
        }
    }
    class UserDataSaving
    {
        /**
         * @var \Flarum\Discussion\UserState
         */
        public $state;
        /**
         * @param \Flarum\Discussion\UserState $state
         */
        public function __construct(\Flarum\Discussion\UserState $state)
        {
        }
    }
    class UserRead
    {
        /**
         * @var UserState
         */
        public $state;
        /**
         * @param UserState $state
         */
        public function __construct(\Flarum\Discussion\UserState $state)
        {
        }
    }
}
namespace Flarum\Query {
    /**
     * @internal
     */
    trait ApplyQueryParametersTrait
    {
        /**
         * Apply sort criteria to a discussion query.
         *
         * @param AbstractQueryState $query
         * @param array $sort
         * @param bool $sortIsDefault
         */
        protected function applySort(\Flarum\Query\AbstractQueryState $query, array $sort = null, bool $sortIsDefault = false)
        {
        }
        /**
         * @param AbstractQueryState $query
         * @param int $offset
         */
        protected function applyOffset(\Flarum\Query\AbstractQueryState $query, $offset)
        {
        }
        /**
         * @param AbstractQueryState $query
         * @param int|null $limit
         */
        protected function applyLimit(\Flarum\Query\AbstractQueryState $query, $limit)
        {
        }
    }
}
namespace Flarum\Filter {
    abstract class AbstractFilterer
    {
        use \Flarum\Query\ApplyQueryParametersTrait;
        protected $filters;
        protected $filterMutators;
        /**
         * @param array $filters
         * @param array $filterMutators
         */
        public function __construct(array $filters, array $filterMutators)
        {
        }
        protected abstract function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder;
        /**
         * @param QueryCriteria $criteria
         * @param mixed|null $limit
         * @param int $offset
         *
         * @return QueryResults
         * @throws InvalidArgumentException
         */
        public function filter(\Flarum\Query\QueryCriteria $criteria, int $limit = null, int $offset = 0) : \Flarum\Query\QueryResults
        {
        }
    }
}
namespace Flarum\Discussion\Filter {
    class DiscussionFilterer extends \Flarum\Filter\AbstractFilterer
    {
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        /**
         * @param DiscussionRepository $discussions
         * @param array $filters
         * @param array $filterMutators
         */
        public function __construct(\Flarum\Discussion\DiscussionRepository $discussions, array $filters, array $filterMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
}
namespace Flarum\Http {
    interface SlugDriverInterface
    {
        public function toSlug(\Flarum\Database\AbstractModel $instance) : string;
        public function fromSlug(string $slug, \Flarum\User\User $actor) : \Flarum\Database\AbstractModel;
    }
}
namespace Flarum\Discussion {
    class IdWithTransliteratedSlugDriver implements \Flarum\Http\SlugDriverInterface
    {
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        public function __construct(\Flarum\Discussion\DiscussionRepository $discussions)
        {
        }
        public function toSlug(\Flarum\Database\AbstractModel $instance) : string
        {
        }
        public function fromSlug(string $slug, \Flarum\User\User $actor) : \Flarum\Database\AbstractModel
        {
        }
    }
}
namespace Flarum\Filter {
    interface FilterInterface
    {
        /**
         * This filter will only be run when a query contains a filter param with this key.
         */
        public function getFilterKey() : string;
        /**
         * Filters a query.
         *
         * @param FilterState $filter
         * @param string $value The value of the requested filter
         */
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate);
    }
}
namespace Flarum\Search {
    interface GambitInterface
    {
        /**
         * Apply conditions to the searcher for a bit of the search string.
         *
         * @param SearchState $search
         * @param string $bit The piece of the search string.
         * @return bool Whether or not the gambit was active for this bit.
         */
        public function apply(\Flarum\Search\SearchState $search, $bit);
    }
    abstract class AbstractRegexGambit implements \Flarum\Search\GambitInterface
    {
        /**
         * The regex pattern to match the bit against.
         */
        protected abstract function getGambitPattern();
        /**
         * {@inheritdoc}
         */
        public function apply(\Flarum\Search\SearchState $search, $bit)
        {
        }
        /**
         * Match the bit against this gambit.
         *
         * @param string $bit
         * @return array
         */
        protected function match($bit)
        {
        }
        /**
         * Apply conditions to the search, given that the gambit was matched.
         *
         * @param SearchState $search The search object.
         * @param array $matches An array of matches from the search bit.
         * @param bool $negate Whether or not the bit was negated, and thus whether
         *     or not the conditions should be negated.
         * @return mixed
         */
        protected abstract function conditions(\Flarum\Search\SearchState $search, array $matches, $negate);
    }
}
namespace Flarum\Discussion\Query {
    class AuthorFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @param \Flarum\User\UserRepository $users
         */
        public function __construct(\Flarum\User\UserRepository $users)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        protected function constrain(\Illuminate\Database\Query\Builder $query, $rawUsernames, $negate)
        {
        }
    }
    class CreatedFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        public function constrain(\Illuminate\Database\Query\Builder $query, ?string $firstDate, ?string $secondDate, $negate)
        {
        }
    }
    class HiddenFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        protected function constrain(\Illuminate\Database\Query\Builder $query, bool $negate)
        {
        }
    }
    class UnreadFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * @var \Flarum\Discussion\DiscussionRepository
         */
        protected $discussions;
        /**
         * @param \Flarum\Discussion\DiscussionRepository $discussions
         */
        public function __construct(\Flarum\Discussion\DiscussionRepository $discussions)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        protected function constrain(\Illuminate\Database\Query\Builder $query, \Flarum\User\User $actor, bool $negate)
        {
        }
    }
}
namespace Flarum\Search {
    abstract class AbstractSearcher
    {
        use \Flarum\Query\ApplyQueryParametersTrait;
        /**
         * @var GambitManager
         */
        protected $gambits;
        /**
         * @var array
         */
        protected $searchMutators;
        public function __construct(\Flarum\Search\GambitManager $gambits, array $searchMutators)
        {
        }
        protected abstract function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder;
        /**
         * @param QueryCriteria $criteria
         * @param int|null $limit
         * @param int $offset
         *
         * @return QueryResults
         * @throws InvalidArgumentException
         */
        public function search(\Flarum\Query\QueryCriteria $criteria, $limit = null, $offset = 0) : \Flarum\Query\QueryResults
        {
        }
    }
}
namespace Flarum\Discussion\Search {
    class DiscussionSearcher extends \Flarum\Search\AbstractSearcher
    {
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * @param DiscussionRepository $discussions
         * @param Dispatcher $events
         * @param GambitManager $gambits
         * @param array $searchMutators
         */
        public function __construct(\Flarum\Discussion\DiscussionRepository $discussions, \Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Search\GambitManager $gambits, array $searchMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
}
namespace Flarum\Discussion\Search\Gambit {
    class FulltextGambit implements \Flarum\Search\GambitInterface
    {
        /**
         * {@inheritdoc}
         */
        public function apply(\Flarum\Search\SearchState $search, $bit)
        {
        }
    }
}
namespace Flarum\Discussion {
    /**
     * Models a discussion-user state record in the database.
     *
     * Stores information about how much of a discussion a user has read. Can also
     * be used to store other information, if the appropriate columns are added to
     * the database, like a user's subscription status for a discussion.
     *
     * @property int $user_id
     * @property int $discussion_id
     * @property \Carbon\Carbon|null $last_read_at
     * @property int|null $last_read_post_number
     * @property Discussion $discussion
     * @property \Flarum\User\User $user
     */
    class UserState extends \Flarum\Database\AbstractModel
    {
        use \Flarum\Foundation\EventGeneratorTrait;
        /**
         * {@inheritdoc}
         */
        protected $table = 'discussion_user';
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['last_read_at'];
        /**
         * Mark the discussion as being read up to a certain point. Raises the
         * DiscussionWasRead event.
         *
         * @param int $number
         * @return $this
         */
        public function read($number)
        {
        }
        /**
         * Define the relationship with the discussion that this state is for.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function discussion()
        {
        }
        /**
         * Define the relationship with the user that this state is for.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Set the keys for a save update query.
         *
         * @param Builder $query
         * @return Builder
         */
        protected function setKeysForSaveQuery($query)
        {
        }
    }
}
namespace Flarum\Extend {
    interface ExtenderInterface
    {
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null);
    }
    class ApiController implements \Flarum\Extend\ExtenderInterface
    {
        private $controllerClass;
        private $beforeDataCallbacks = [];
        private $beforeSerializationCallbacks = [];
        private $serializer;
        private $addIncludes = [];
        private $removeIncludes = [];
        private $addOptionalIncludes = [];
        private $removeOptionalIncludes = [];
        private $limit;
        private $maxLimit;
        private $addSortFields = [];
        private $removeSortFields = [];
        private $sort;
        private $load = [];
        private $loadCallables = [];
        /**
         * @param string $controllerClass: The ::class attribute of the controller you are modifying.
         *                                This controller should extend from \Flarum\Api\Controller\AbstractSerializeController.
         */
        public function __construct(string $controllerClass)
        {
        }
        /**
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * @return self
         */
        public function prepareDataQuery($callback) : self
        {
        }
        /**
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         * - $data: Mixed, can be an array of data or an object (like an instance of Collection or AbstractModel).
         * - $request: An instance of \Psr\Http\Message\ServerRequestInterface.
         * - $document: An instance of \Tobscure\JsonApi\Document.
         *
         * The callable should return:
         * - An array of additional data to merge with the existing array.
         *   Or a modified $data array.
         *
         * @return self
         */
        public function prepareDataForSerialization($callback) : self
        {
        }
        /**
         * Set the serializer that will serialize data for the endpoint.
         *
         * @param string $serializerClass: The ::class attribute of the serializer.
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function setSerializer(string $serializerClass, $callback = null) : self
        {
        }
        /**
         * Include the given relationship by default.
         *
         * @param string|array $name: The name of the relation.
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function addInclude($name, $callback = null) : self
        {
        }
        /**
         * Don't include the given relationship by default.
         *
         * @param string|array $name: The name of the relation.
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function removeInclude($name, $callback = null) : self
        {
        }
        /**
         * Make the given relationship available for inclusion.
         *
         * @param string|array $name: The name of the relation.
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function addOptionalInclude($name, $callback = null) : self
        {
        }
        /**
         * Don't allow the given relationship to be included.
         *
         * @param string|array $name: The name of the relation.
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function removeOptionalInclude($name, $callback = null) : self
        {
        }
        /**
         * Set the default number of results.
         *
         * @param int $limit
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function setLimit(int $limit, $callback = null) : self
        {
        }
        /**
         * Set the maximum number of results.
         *
         * @param int $max
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function setMaxLimit(int $max, $callback = null) : self
        {
        }
        /**
         * Allow sorting results by the given field.
         *
         * @param string|array $field
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function addSortField($field, $callback = null) : self
        {
        }
        /**
         * Disallow sorting results by the given field.
         *
         * @param string|array $field
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function removeSortField($field, $callback = null) : self
        {
        }
        /**
         * Set the default sort order for the results.
         *
         * @param array $sort
         * @param callable|string|null $callback
         *
         * The optional callback can be a closure or an invokable class, and should accept:
         * - $controller: An instance of this controller.
         *
         * The callable should return:
         * - A boolean value to determine if this applies.
         *
         * @return self
         */
        public function setSort(array $sort, $callback = null) : self
        {
        }
        /**
         * Eager loads relationships needed for serializer logic.
         *
         * First level relationships will be loaded regardless of whether they are included in the response.
         * Sublevel relationships will only be loaded if the upper level was included or manually loaded.
         *
         * @example If a relationship such as: 'relation.subRelation' is specified,
         * it will only be loaded if 'relation' is or has been loaded.
         * To force load the relationship, both levels have to be specified,
         * example: ['relation', 'relation.subRelation'].
         *
         * @param string|string[] $relations
         * @return self
         */
        public function load($relations) : self
        {
        }
        /**
         * Allows loading a relationship with additional query modification.
         *
         * @param string $relation: Relationship name, see load method description.
         * @param callable(\Illuminate\Database\Query\Builder|\Illuminate\Database\Eloquent\Relations\Relation, \Psr\Http\Message\ServerRequestInterface|null, array): void $callback
         *
         * The callback to modify the query, should accept:
         * - \Illuminate\Database\Query\Builder|\Illuminate\Database\Eloquent\Relations\Relation $query: A query object.
         * - \Psr\Http\Message\ServerRequestInterface|null $request: An instance of the request.
         * - array $relations: An array of relations that are to be loaded.
         *
         * @return self
         */
        public function loadWhere(string $relation, callable $callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * @param callable|string|null $callback
         * @param AbstractSerializeController $controller
         * @param Container $container
         * @return bool
         */
        private function isApplicable($callback, \Flarum\Api\Controller\AbstractSerializeController $controller, \Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    class ApiSerializer implements \Flarum\Extend\ExtenderInterface
    {
        private $serializerClass;
        private $attribute = [];
        private $attributes = [];
        private $relationships = [];
        /**
         * @param string $serializerClass The ::class attribute of the serializer you are modifying.
         *                                This serializer should extend from \Flarum\Api\Serializer\AbstractSerializer.
         */
        public function __construct(string $serializerClass)
        {
        }
        /**
         * Add a single attribute to this serializer.
         *
         * @param string $name: The name of the attribute.
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - $serializer: An instance of this serializer.
         * - $model: An instance of the model being serialized.
         * - $attributes: An array of existing attributes.
         *
         * The callable should return:
         * - The value of the attribute.
         *
         * @return self
         */
        public function attribute(string $name, $callback) : self
        {
        }
        /**
         * Add to or modify the attributes array of this serializer.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - $serializer: An instance of this serializer.
         * - $model: An instance of the model being serialized.
         * - $attributes: An array of existing attributes.
         *
         * The callable should return:
         * - An array of additional attributes to merge with the existing array.
         *   Or a modified $attributes array.
         *
         * @return self
         */
        public function attributes($callback) : self
        {
        }
        /**
         * Establish a simple hasOne relationship from this serializer to another serializer.
         * This represents a one-to-one relationship.
         *
         * @param string $name: The name of the relation. Has to be unique from other relation names.
         *                      The relation has to exist in the model handled by this serializer.
         * @param string $serializerClass: The ::class attribute the serializer that handles this relation.
         *                                 This serializer should extend from \Flarum\Api\Serializer\AbstractSerializer.
         * @return self
         */
        public function hasOne(string $name, string $serializerClass) : self
        {
        }
        /**
         * Establish a simple hasMany relationship from this serializer to another serializer.
         * This represents a one-to-many relationship.
         *
         * @param string $name: The name of the relation. Has to be unique from other relation names.
         *                      The relation has to exist in the model handled by this serializer.
         * @param string $serializerClass: The ::class attribute the serializer that handles this relation.
         *                                 This serializer should extend from \Flarum\Api\Serializer\AbstractSerializer.
         * @return self
         */
        public function hasMany(string $name, string $serializerClass) : self
        {
        }
        /**
         * Add a relationship from this serializer to another serializer.
         *
         * @param string $name: The name of the relation. Has to be unique from other relation names.
         *                      The relation has to exist in the model handled by this serializer.
         * @param callable|string $callback
         *
         * The callable can be a closure or an invokable class, and should accept:
         * - $serializer: An instance of this serializer.
         * - $model: An instance of the model being serialized.
         *
         * The callable should return:
         * - $relationship: An instance of \Tobscure\JsonApi\Relationship.
         *
         * @return self
         */
        public function relationship(string $name, $callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Auth implements \Flarum\Extend\ExtenderInterface
    {
        private $addPasswordCheckers = [];
        private $removePasswordCheckers = [];
        /**
         * Add a new password checker.
         *
         * @param string $identifier: Unique identifier for password checker.
         * @param callable|string $callback: A closure or invokable class that contains the logic of the password checker.
         *
         * The callable should accept:
         * - $user: An instance of the User model.
         * - $password: A string.
         *
         * The callable should return:
         * - `true` if the given password is valid.
         * - `null` (or not return anything) if the given password is invalid, or this checker does not apply.
         *           Generally, `null` should be returned instead of `false` so that other
         *           password checkers can run.
         * - `false` if the given password is invalid, and no other checkers should be considered.
         *            Evaluation will be immediately halted if any checkers return `false`.
         *
         * @return self
         */
        public function addPasswordChecker(string $identifier, $callback) : self
        {
        }
        /**
         * Remove a password checker.
         *
         * @param string $identifier: The unique identifier of the password checker to remove.
         * @return self
         */
        public function removePasswordChecker(string $identifier) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Console implements \Flarum\Extend\ExtenderInterface
    {
        protected $addCommands = [];
        protected $scheduled = [];
        /**
         * Add a command to the console.
         *
         * @param string $command: ::class attribute of command class, which must extend Flarum\Console\AbstractCommand.
         * @return self
         */
        public function command(string $command) : self
        {
        }
        /**
         * Schedule a command to run on an interval.
         *
         * @param string $command: ::class attribute of command class, which must extend Flarum\Console\AbstractCommand.
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \Illuminate\Console\Scheduling\Event $event
         *
         * The callback should apply relevant methods to $event, and does not need to return anything.
         *
         * @see https://laravel.com/api/8.x/Illuminate/Console/Scheduling/Event.html
         * @see https://laravel.com/docs/8.x/scheduling#schedule-frequency-options
         * for more information on available methods and what they do.
         *
         * @param array $args An array of args to call the command with.
         * @return self
         */
        public function schedule(string $command, $callback, $args = []) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Csrf implements \Flarum\Extend\ExtenderInterface
    {
        protected $csrfExemptRoutes = [];
        /**
         * Exempt a named route from CSRF checks.
         *
         * @param string $routeName
         * @return self
         */
        public function exemptRoute(string $routeName) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class ErrorHandling implements \Flarum\Extend\ExtenderInterface
    {
        private $statuses = [];
        private $types = [];
        private $handlers = [];
        private $reporters = [];
        /**
         * Define the corresponding HTTP status code for a well-known error type.
         *
         * This can be used to configure the status code (second parameter) to be
         * used for the error response when encountering an exception with a certain
         * type (first parameter). This type can be provided by the exception class
         * itself (if it implements {@see \Flarum\Foundation\KnownError}), or
         * explicitly defined by using the {@see type} method (useful for exception
         * classes not under your control).
         *
         * @param string $errorType: Type of the error.
         * @param int $httpStatus: The status code for this error.
         * @return self
         */
        public function status(string $errorType, int $httpStatus) : self
        {
        }
        /**
         * Define the internal error type for a specific exception class.
         *
         * If the exception class is under your control, you should prefer having
         * the exception implement our {@see \Flarum\Foundation\KnownError}
         * interface and define the type there. This method should only be used for
         * third-party exceptions, e.g. when integrating another package that
         * already defines its own exception classes.
         *
         * @param string $exceptionClass: The ::class attribute of the exception class.
         * @param string $errorType: Type of the error.
         * @return self
         */
        public function type(string $exceptionClass, string $errorType) : self
        {
        }
        /**
         * Register a handler with custom error handling logic.
         *
         * When Flarum's default error handling is not enough for you, and the other
         * methods of this extender don't help, this is the place where you can go
         * wild! Using this method, you can define a handler class (second
         * parameter) that will be responsible for exceptions of a certain type
         * (first parameter).
         *
         * The handler class must implement a handle() method (surprise!), which
         * returns a {@see \Flarum\Foundation\ErrorHandling\HandledError} instance.
         * Besides the usual type and HTTP status code, such an object can also
         * contain "details" - arbitrary data with more context for to the error.
         *
         * @param string $exceptionClass: The ::class attribute of the exception class.
         * @param string $errorType: The ::class attribute of the handler class.
         * @return self
         */
        public function handler(string $exceptionClass, string $handlerClass) : self
        {
        }
        /**
         * Register an error reporter.
         *
         * Reporters will be called whenever Flarum encounters an exception that it
         * does not know how to handle (i.e. none of the well-known exceptions that
         * have an associated error type). They can then e.g. write the exception to
         * a log, or send it to some external service, so that developers and/or
         * administrators are notified about the error.
         *
         * When passing in a reporter class, make sure that it implements the
         * {@see \Flarum\Foundation\ErrorHandling\Reporter} interface.
         *
         * @param string $reporterClass: The ::class attribute of the reporter class.
         * @return self
         */
        public function reporter(string $reporterClass) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Event implements \Flarum\Extend\ExtenderInterface
    {
        private $listeners = [];
        private $subscribers = [];
        /**
         * Add a listener to a domain event dispatched by flarum or a flarum extension.
         *
         * @param string $event: Name of the event, can be the ::class attribute of the event class.
         * @param callable|string $listener
         *
         * The listener can either be:
         *  - A callback function that accepts an instance of the event as a parameter.
         *  - The ::class attribute of a class with a public `handle` method, which accepts an instance of the event as a parameter.
         *  - An array, where the first argument is an object or class name, and the second argument is the method on the
         *    first argument that should be executed as the listener.
         *
         * @return self
         */
        public function listen(string $event, $listener) : self
        {
        }
        /**
         * Add a subscriber for a set of domain events dispatched by flarum or a flarum extension.
         * Event subscribers are classes that may subscribe to multiple events from within the subscriber class itself,
         * allowing you to define several event handlers within a single class.
         *
         * @see https://laravel.com/docs/8.x/events#writing-event-subscribers
         *
         * @param string $subscriber: The ::class attribute of the subscriber class.
         * @return self
         */
        public function subscribe(string $subscriber) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Filesystem implements \Flarum\Extend\ExtenderInterface
    {
        private $disks = [];
        private $drivers = [];
        /**
         * Declare a new filesystem disk.
         * Disks represent storage locations, and are backed by storage drivers.
         * Flarum core uses disks for storing assets and avatars.
         *
         * By default, the "local" driver will be used for disks.
         * The "local" driver represents the filesystem where your Flarum installation is running.
         *
         * To declare a new disk, you must provide default configuration a "local" driver.
         *
         * @param string $name: The name of the disk.
         * @param string|callable $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         *  - \Flarum\Foundation\Paths $paths
         *  - \Flarum\Http\UrlGenerator $url
         *
         * The callable should return:
         * - A Laravel disk config array,
         *   The `driver` key is not necessary for this array, and will be ignored.
         *
         * @example
         * ```
         * ->disk('flarum-uploads', function (Paths $paths, UrlGenerator $url) {
         *       return [
         *          'root'   => "$paths->public/assets/uploads",
         *          'url'    => $url->to('forum')->path('assets/uploads')
         *       ];
         *   });
         * ```
         *
         * @see https://laravel.com/docs/8.x/filesystem#configuration
         *
         * @return self
         */
        public function disk(string $name, $callback) : self
        {
        }
        /**
         * Register a new filesystem driver.
         *
         * @param string $name: The name of the driver.
         * @param string $driverClass: The ::class attribute of the driver.
         *                             Driver must implement `\Flarum\Filesystem\DriverInterface`.
         * @return self
         */
        public function driver(string $name, string $driverClass) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Filter implements \Flarum\Extend\ExtenderInterface
    {
        private $filtererClass;
        private $filters = [];
        private $filterMutators = [];
        /**
         * @param string $filtererClass: The ::class attribute of the filterer to extend.
         */
        public function __construct($filtererClass)
        {
        }
        /**
         * Add a filter to run when the filtererClass is filtered.
         *
         * @param string $filterClass: The ::class attribute of the filter you are adding.
         * @return self
         */
        public function addFilter(string $filterClass) : self
        {
        }
        /**
         * Add a callback through which to run all filter queries after filters have been applied.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - Flarum\Filter\FilterState $filter
         * - Flarum\Query\QueryCriteria $criteria
         *
         * The callable should return void.
         *
         * @return self
         */
        public function addFilterMutator($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    interface LifecycleInterface
    {
        public function onEnable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension);
        public function onDisable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension);
    }
    class Formatter implements \Flarum\Extend\ExtenderInterface, \Flarum\Extend\LifecycleInterface
    {
        private $configurationCallbacks = [];
        private $parsingCallbacks = [];
        private $unparsingCallbacks = [];
        private $renderingCallbacks = [];
        /**
         * Configure the formatter. This can be used to add support for custom markdown/bbcode/etc tags,
         * or otherwise change the formatter. Please see documentation for the s9e text formatter library for more
         * information on how to use this.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \s9e\TextFormatter\Configurator $configurator
         *
         * The callable should return void.
         *
         * @return self
         */
        public function configure($callback) : self
        {
        }
        /**
         * Prepare the system for parsing. This can be used to modify the text that will be parsed, or to modify the parser.
         * Please note that the text to be parsed must be returned, regardless of whether it's changed.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \s9e\TextFormatter\Parser $parser
         * - mixed $context
         * - string $text: The text to be parsed.
         *
         * The callback should return:
         * - string $text: The text to be parsed.
         *
         * @return self
         */
        public function parse($callback) : self
        {
        }
        /**
         * Prepare the system for unparsing. This can be used to modify the text that was parsed.
         * Please note that the parsed text must be returned, regardless of whether it's changed.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - mixed $context
         * - string $xml: The parsed text.
         *
         * The callback should return:
         * - string $xml: The text to be unparsed.
         *
         * @return self
         */
        public function unparse($callback) : self
        {
        }
        /**
         * Prepare the system for rendering. This can be used to modify the xml that will be rendered, or to modify the renderer.
         * Please note that the xml to be rendered must be returned, regardless of whether it's changed.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \s9e\TextFormatter\Rendered $renderer
         * - mixed $context
         * - string $xml: The xml to be rendered.
         * - ServerRequestInterface $request. This argument MUST either be nullable, or omitted entirely.
         *
         * The callback should return:
         * - string $xml: The xml to be rendered.
         *
         * @return self
         */
        public function render($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        public function onEnable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
        public function onDisable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
    }
    class Frontend implements \Flarum\Extend\ExtenderInterface
    {
        private $frontend;
        private $css = [];
        private $js;
        private $routes = [];
        private $removedRoutes = [];
        private $content = [];
        private $preloadArrs = [];
        private $titleDriver;
        /**
         * @param string $frontend: The name of the frontend.
         */
        public function __construct(string $frontend)
        {
        }
        /**
         * Add a CSS file to load in the frontend.
         *
         * @param string $path: The path to the CSS file.
         * @return self
         */
        public function css(string $path) : self
        {
        }
        /**
         * Add a JavaScript file to load in the frontend.
         *
         * @param string $path: The path to the JavaScript file.
         * @return self
         */
        public function js(string $path) : self
        {
        }
        /**
         * Add a route to the frontend.
         *
         * @param string $path: The path of the route.
         * @param string $name: The name of the route, must be unique.
         * @param callable|string|null $content
         *
         * The content can be a closure or an invokable class, and should accept:
         * - \Flarum\Frontend\Document $document
         * - \Psr\Http\Message\ServerRequestInterface $request
         *
         * The callable should return void.
         *
         * @return self
         */
        public function route(string $path, string $name, $content = null) : self
        {
        }
        /**
         * Remove a route from the frontend.
         * This is necessary before overriding a route.
         *
         * @param string $name: The name of the route.
         * @return self
         */
        public function removeRoute(string $name) : self
        {
        }
        /**
         * Modify the content of the frontend.
         *
         * @param callable|string|null $content
         *
         * The content can be a closure or an invokable class, and should accept:
         * - \Flarum\Frontend\Document $document
         * - \Psr\Http\Message\ServerRequestInterface $request
         *
         * The callable should return void.
         *
         * @return self
         */
        public function content($callback) : self
        {
        }
        /**
         * Adds multiple asset preloads.
         *
         * The parameter should be an array of preload arrays, or a callable that returns this.
         *
         * A preload array must contain keys that pertain to the `<link rel="preload">` tag.
         *
         * For example, the following will add preload tags for a script and font file:
         * ```
         * $frontend->preloads([
         *   [
         *     'href' => '/assets/my-script.js',
         *     'as' => 'script',
         *   ],
         *   [
         *     'href' => '/assets/fonts/my-font.woff2',
         *     'as' => 'font',
         *     'type' => 'font/woff2',
         *     'crossorigin' => ''
         *   ]
         * ]);
         * ```
         *
         * @param callable|array $preloads
         * @return self
         */
        public function preloads($preloads) : self
        {
        }
        /**
         * Register a new title driver to change the title of frontend documents.
         */
        public function title(string $driverClass) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        private function registerAssets(\Illuminate\Contracts\Container\Container $container, string $moduleName) : void
        {
        }
        private function registerRoutes(\Illuminate\Contracts\Container\Container $container) : void
        {
        }
        private function registerContent(\Illuminate\Contracts\Container\Container $container) : void
        {
        }
        private function registerPreloads(\Illuminate\Contracts\Container\Container $container) : void
        {
        }
        private function getModuleName(?\Flarum\Extension\Extension $extension) : string
        {
        }
        private function registerTitleDriver(\Illuminate\Contracts\Container\Container $container) : void
        {
        }
    }
    class LanguagePack implements \Flarum\Extend\ExtenderInterface, \Flarum\Extend\LifecycleInterface
    {
        private const CORE_LOCALE_FILES = ['core', 'validation'];
        private $path;
        /**
         * LanguagePack constructor.
         *
         * @param string|null $path: Path to yaml language files.
         */
        public function __construct(string $path = '/locale')
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        private function registerLocale(\Illuminate\Contracts\Container\Container $container, \Flarum\Locale\LocaleManager $locales, \Flarum\Extension\Extension $extension, $locale, $title)
        {
        }
        private function shouldLoad(\SplFileInfo $file, \Illuminate\Contracts\Container\Container $container)
        {
        }
        public function onEnable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
        public function onDisable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
    }
    class Locales implements \Flarum\Extend\ExtenderInterface, \Flarum\Extend\LifecycleInterface
    {
        private $directory;
        /**
         * @param string $directory: Directory of the locale files.
         */
        public function __construct(string $directory)
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        public function onEnable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
        public function onDisable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
    }
    class Mail implements \Flarum\Extend\ExtenderInterface
    {
        private $drivers = [];
        /**
         * Add a mail driver.
         *
         * @param string $identifier: Identifier for mail driver. E.g. 'smtp' for SmtpDriver.
         * @param string $driver: ::class attribute of driver class, which must implement Flarum\Mail\DriverInterface.
         * @return self
         */
        public function driver(string $identifier, string $driver) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Middleware implements \Flarum\Extend\ExtenderInterface
    {
        private $addMiddlewares = [];
        private $removeMiddlewares = [];
        private $replaceMiddlewares = [];
        private $insertBeforeMiddlewares = [];
        private $insertAfterMiddlewares = [];
        private $frontend;
        /**
         * @param string $frontend: The name of the frontend.
         */
        public function __construct(string $frontend)
        {
        }
        /**
         * Adds a new middleware to the frontend.
         *
         * @param string $middleware: ::class attribute of the middleware class.
         *                            Must implement \Psr\Http\Server\MiddlewareInterface.
         * @return self
         */
        public function add(string $middleware) : self
        {
        }
        /**
         * Replaces an existing middleware of the frontend.
         *
         * @param string $originalMiddleware: ::class attribute of the original middleware class.
         *                                    Or container binding name.
         * @param string $middleware: ::class attribute of the middleware class.
         *                            Must implement \Psr\Http\Server\MiddlewareInterface.
         * @return self
         */
        public function replace(string $originalMiddleware, string $newMiddleware) : self
        {
        }
        /**
         * Removes a middleware from the frontend.
         *
         * @param string $middleware: ::class attribute of the middleware class.
         * @return self
         */
        public function remove(string $middleware) : self
        {
        }
        /**
         * Inserts a middleware before an existing middleware.
         *
         * @param string $originalMiddleware: ::class attribute of the original middleware class.
         *                                    Or container binding name.
         * @param string $middleware: ::class attribute of the middleware class.
         *                            Must implement \Psr\Http\Server\MiddlewareInterface.
         * @return self
         */
        public function insertBefore(string $originalMiddleware, string $newMiddleware) : self
        {
        }
        /**
         * Inserts a middleware after an existing middleware.
         *
         * @param string $originalMiddleware: ::class attribute of the original middleware class.
         *                                    Or container binding name.
         * @param string $middleware: ::class attribute of the middleware class.
         *                            Must implement \Psr\Http\Server\MiddlewareInterface.
         * @return self
         */
        public function insertAfter(string $originalMiddleware, string $newMiddleware) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Model implements \Flarum\Extend\ExtenderInterface
    {
        private $modelClass;
        private $customRelations = [];
        /**
         * @param string $modelClass: The ::class attribute of the model you are modifying.
         *                           This model should extend from \Flarum\Database\AbstractModel.
         */
        public function __construct(string $modelClass)
        {
        }
        /**
         * Add an attribute to be treated as a date.
         *
         * @param string $attribute
         * @return self
         */
        public function dateAttribute(string $attribute) : self
        {
        }
        /**
         * Add a default value for a given attribute, which can be an explicit value, a closure,
         * or an instance of an invokable class. Unlike with some other extenders,
         * it CANNOT be the `::class` attribute of an invokable class.
         *
         * @param string $attribute
         * @param mixed $value
         * @return self
         */
        public function default(string $attribute, $value) : self
        {
        }
        /**
         * Establish a simple belongsTo relationship from this model to another model.
         * This represents an inverse one-to-one or inverse one-to-many relationship.
         * For more complex relationships, use the ->relationship method.
         *
         * @param string $name: The name of the relation. This doesn't have to be anything in particular,
         *                      but has to be unique from other relation names for this model, and should
         *                      work as the name of a method.
         * @param string $related: The ::class attribute of the model, which should extend \Flarum\Database\AbstractModel.
         * @param string $foreignKey: The foreign key attribute of the parent model.
         * @param string $ownerKey: The primary key attribute of the parent model.
         * @return self
         */
        public function belongsTo(string $name, string $related, string $foreignKey = null, string $ownerKey = null) : self
        {
        }
        /**
         * Establish a simple belongsToMany relationship from this model to another model.
         * This represents a many-to-many relationship.
         * For more complex relationships, use the ->relationship method.
         *
         * @param string $name: The name of the relation. This doesn't have to be anything in particular,
         *                      but has to be unique from other relation names for this model, and should
         *                      work as the name of a method.
         * @param string $related: The ::class attribute of the model, which should extend \Flarum\Database\AbstractModel.
         * @param string $table: The intermediate table for this relation
         * @param string $foreignPivotKey: The foreign key attribute of the parent model.
         * @param string $relatedPivotKey: The associated key attribute of the relation.
         * @param string $parentKey: The key name of the parent model.
         * @param string $relatedKey: The key name of the related model.
         * @return self
         */
        public function belongsToMany(string $name, string $related, string $table = null, string $foreignPivotKey = null, string $relatedPivotKey = null, string $parentKey = null, string $relatedKey = null) : self
        {
        }
        /**
         * Establish a simple hasOne relationship from this model to another model.
         * This represents a one-to-one relationship.
         * For more complex relationships, use the ->relationship method.
         *
         * @param string $name: The name of the relation. This doesn't have to be anything in particular,
         *                      but has to be unique from other relation names for this model, and should
         *                      work as the name of a method.
         * @param string $related: The ::class attribute of the model, which should extend \Flarum\Database\AbstractModel.
         * @param string $foreignKey: The foreign key attribute of the parent model.
         * @param string $localKey: The primary key attribute of the parent model.
         * @return self
         */
        public function hasOne(string $name, string $related, string $foreignKey = null, string $localKey = null) : self
        {
        }
        /**
         * Establish a simple hasMany relationship from this model to another model.
         * This represents a one-to-many relationship.
         * For more complex relationships, use the ->relationship method.
         *
         * @param string $name: The name of the relation. This doesn't have to be anything in particular,
         *                      but has to be unique from other relation names for this model, and should
         *                      work as the name of a method.
         * @param string $related: The ::class attribute of the model, which should extend \Flarum\Database\AbstractModel.
         * @param string $foreignKey: The foreign key attribute of the parent model.
         * @param string $localKey: The primary key attribute of the parent model.
         * @return self
         */
        public function hasMany(string $name, string $related, string $foreignKey = null, string $localKey = null) : self
        {
        }
        /**
         * Add a relationship from this model to another model.
         *
         * @param string $name: The name of the relation. This doesn't have to be anything in particular,
         *                      but has to be unique from other relation names for this model, and should
         *                      work as the name of a method.
         * @param callable|string $callback
         *
         * The callable can be a closure or invokable class, and should accept:
         * - $instance: An instance of this model.
         *
         * The callable should return:
         * - $relationship: A Laravel Relationship object. See relevant methods of models
         *                  like \Flarum\User\User for examples of how relationships should be returned.
         *
         * @return self
         */
        public function relationship(string $name, $callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    /**
     * Some models, in particular Discussion and CommentPost, are intended to
     * support a "private" mode, wherein they aren't visible unless some
     * criteria is met. This can be used to implement anything from
     * private discussions to post approvals.
     *
     * When a model is saved, any "privacy checkers" registered for it will
     * be run. If any privacy checkers return `true`, the `is_private` field
     * of that model instance will be set to `true`. Otherwise, it will be set to
     * `false`. Accordingly, this is only available for models with an `is_private`
     * field.
     *
     * In Flarum core, the Discussion and CommentPost models come with private support.
     * Core also contains visibility scopers that hide instances of these models
     * with `is_private = true` from queries. Extensions can register custom scopers
     * for these classes with the `viewPrivate` ability to grant access to view some
     * private instances under some conditions.
     */
    class ModelPrivate implements \Flarum\Extend\ExtenderInterface
    {
        private $modelClass;
        private $checkers = [];
        /**
         * @param string $modelClass: The ::class attribute of the model you are applying private checkers to.
         *                           This model must have a `is_private` field.
         */
        public function __construct(string $modelClass)
        {
        }
        /**
         * Add a model privacy checker.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \Flarum\Database\AbstractModel $instance: An instance of the model.
         *
         * It should return `true` if the model instance should be made private.
         *
         * @return self
         */
        public function checker($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class ModelUrl implements \Flarum\Extend\ExtenderInterface
    {
        private $modelClass;
        private $slugDrivers = [];
        /**
         * @param string $modelClass: The ::class attribute of the model you are modifying.
         *                           This model should extend from \Flarum\Database\AbstractModel.
         */
        public function __construct(string $modelClass)
        {
        }
        /**
         * Add a slug driver.
         *
         * @param string $identifier: Identifier for slug driver.
         * @param string $driver: ::class attribute of driver class, which must implement Flarum\Http\SlugDriverInterface.
         * @return self
         */
        public function addSlugDriver(string $identifier, string $driver) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    /**
     * Model visibility scoping allows us to scope queries based on the current user.
     * The main usage of this is only showing model instances that a user is allowed to see.
     *
     * This is done by running a query through a series of "scoper" callbacks, which apply
     * additional `where`s to the query based on the user.
     *
     * Scopers are classified under an ability. Calling `whereVisibleTo` on a query
     * will apply scopers under the `view` ability. Generally, the main `view` scopers
     * can request scoping with other abilities, which provides an entrypoint for extensions
     * to modify some restriction to a query.
     *
     * Scopers registered via `scopeAll` will apply to all queries under a model, regardless
     * of the ability, and will accept the ability name as an additional argument.
     */
    class ModelVisibility implements \Flarum\Extend\ExtenderInterface
    {
        private $modelClass;
        private $scopers = [];
        private $allScopers = [];
        /**
         * @param string $modelClass: The ::class attribute of the model you are applying scopers to.
         *                           This model must extend from \Flarum\Database\AbstractModel,
         *                           and use \Flarum\Database\ScopeVisibilityTrait.
         */
        public function __construct(string $modelClass)
        {
        }
        /**
         * Add a scoper for a given ability.
         *
         * @param callable|string $callback
         * @param string $ability: Defaults to 'view'.
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \Flarum\User\User $actor
         * - \Illuminate\Database\Eloquent\Builder $query
         *
         * The callback should return void.
         *
         * @return self
         */
        public function scope($callback, string $ability = 'view') : self
        {
        }
        /**
         * Add a scoper scoper that will always run for this model, regardless of requested ability.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \Flarum\User\User $actor
         * - \Illuminate\Database\Eloquent\Builder $query
         * - string $ability
         *
         * The callback should return void.
         *
         * @return self
         */
        public function scopeAll($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Notification implements \Flarum\Extend\ExtenderInterface
    {
        private $blueprints = [];
        private $serializers = [];
        private $drivers = [];
        private $typesEnabledByDefault = [];
        private $beforeSendingCallbacks = [];
        /**
         * @param string $blueprint: The ::class attribute of the blueprint class.
         *                          This blueprint should implement \Flarum\Notification\Blueprint\BlueprintInterface.
         * @param string $serializer: The ::class attribute of the serializer class.
         *                           This serializer should extend from \Flarum\Api\Serializer\AbstractSerializer.
         * @param string[] $driversEnabledByDefault: The names of the drivers enabled by default for this notification type.
         *                                       (example: alert, email).
         * @return self
         */
        public function type(string $blueprint, string $serializer, array $driversEnabledByDefault = []) : self
        {
        }
        /**
         * @param string $driverName: The name of the notification driver.
         * @param string $driver: The ::class attribute of the driver class.
         *                       This driver should implement \Flarum\Notification\Driver\NotificationDriverInterface.
         * @param string[] $typesEnabledByDefault: The names of blueprint classes of types enabled by default for this driver.
         * @return self
         */
        public function driver(string $driverName, string $driver, array $typesEnabledByDefault = []) : self
        {
        }
        /**
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - \Flarum\Notification\Blueprint\BlueprintInterface $blueprint
         * - \Flarum\User\User[] $newRecipients
         *
         * The callable should return an array of recipients.
         * - \Flarum\User\User[] $newRecipients
         *
         * @return self
         */
        public function beforeSending($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Policy implements \Flarum\Extend\ExtenderInterface
    {
        private $globalPolicies = [];
        private $modelPolicies = [];
        /**
         * Add a custom policy for when an ability check is ran without a model instance.
         *
         * @param string $policy: ::class attribute of policy class, which must extend Flarum\User\Access\AbstractPolicy
         * @return self
         */
        public function globalPolicy(string $policy) : self
        {
        }
        /**
         * Add a custom policy for when an ability check is ran on an instance of a model.
         *
         * @param string $modelClass: The ::class attribute of the model you are applying policies to.
         *                           This model should extend from \Flarum\Database\AbstractModel.
         * @param string $policy: ::class attribute of policy class, which must extend Flarum\User\Access\AbstractPolicy
         * @return self
         */
        public function modelPolicy(string $modelClass, string $policy) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Post implements \Flarum\Extend\ExtenderInterface
    {
        private $postTypes = [];
        /**
         * Register a new post type. This is generally done for custom 'event posts',
         * such as those that appear when a discussion is renamed.
         *
         * @param string $postType: The ::class attribute of the custom Post type that is being added.
         * @return self
         */
        public function type(string $postType) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Routes implements \Flarum\Extend\ExtenderInterface
    {
        private $appName;
        private $routes = [];
        private $removedRoutes = [];
        /**
         * @param string $appName: Name of the app (api, forum, admin).
         */
        public function __construct(string $appName)
        {
        }
        /**
         * Add a GET route.
         *
         * @param string $path: The path of the route
         * @param string $name: The name of the route, must be unique.
         * @param callable|string $handler: ::class attribute of the controller class, or a closure.
         *
         * If the handler is a controller class, it should implement \Psr\Http\Server\RequestHandlerInterface,
         * or extend one of the Flarum Api controllers within \Flarum\Api\Controller.
         *
         * The handler should accept:
         * - \Psr\Http\Message\ServerRequestInterface $request
         * - \Tobscure\JsonApi\Document $document: If it extends one of the Flarum Api controllers.
         *
         * The handler should return:
         * - \Psr\Http\Message\ResponseInterface $response
         *
         * @return self
         */
        public function get(string $path, string $name, $handler) : self
        {
        }
        /**
         * Add a POST route.
         *
         * @param string $path: The path of the route
         * @param string $name: The name of the route, must be unique.
         * @param callable|string $handler: ::class attribute of the controller class, or a closure.
         *
         * If the handler is a controller class, it should implement \Psr\Http\Server\RequestHandlerInterface,
         * or extend one of the Flarum Api controllers within \Flarum\Api\Controller.
         *
         * The handler should accept:
         * - \Psr\Http\Message\ServerRequestInterface $request
         * - \Tobscure\JsonApi\Document $document: If it extends one of the Flarum Api controllers.
         *
         * The handler should return:
         * - \Psr\Http\Message\ResponseInterface $response
         *
         * @return self
         */
        public function post(string $path, string $name, $handler) : self
        {
        }
        /**
         * Add a PUT route.
         *
         * @param string $path: The path of the route
         * @param string $name: The name of the route, must be unique.
         * @param callable|string $handler: ::class attribute of the controller class, or a closure.
         *
         * If the handler is a controller class, it should implement \Psr\Http\Server\RequestHandlerInterface,
         * or extend one of the Flarum Api controllers within \Flarum\Api\Controller.
         *
         * The handler should accept:
         * - \Psr\Http\Message\ServerRequestInterface $request
         * - \Tobscure\JsonApi\Document $document: If it extends one of the Flarum Api controllers.
         *
         * The handler should return:
         * - \Psr\Http\Message\ResponseInterface $response
         *
         * @return self
         */
        public function put(string $path, string $name, $handler) : self
        {
        }
        /**
         * Add a PATCH route.
         *
         * @param string $path: The path of the route
         * @param string $name: The name of the route, must be unique.
         * @param callable|string $handler: ::class attribute of the controller class, or a closure.
         *
         * If the handler is a controller class, it should implement \Psr\Http\Server\RequestHandlerInterface,
         * or extend one of the Flarum Api controllers within \Flarum\Api\Controller.
         *
         * The handler should accept:
         * - \Psr\Http\Message\ServerRequestInterface $request
         * - \Tobscure\JsonApi\Document $document: If it extends one of the Flarum Api controllers.
         *
         * The handler should return:
         * - \Psr\Http\Message\ResponseInterface $response
         *
         * @return self
         */
        public function patch(string $path, string $name, $handler) : self
        {
        }
        /**
         * Add a DELETE route.
         *
         * @param string $path: The path of the route
         * @param string $name: The name of the route, must be unique.
         * @param callable|string $handler: ::class attribute of the controller class, or a closure.
         *
         * If the handler is a controller class, it should implement \Psr\Http\Server\RequestHandlerInterface,
         * or extend one of the Flarum Api controllers within \Flarum\Api\Controller.
         *
         * The handler should accept:
         * - \Psr\Http\Message\ServerRequestInterface $request
         * - \Tobscure\JsonApi\Document $document: If it extends one of the Flarum Api controllers.
         *
         * The handler should return:
         * - \Psr\Http\Message\ResponseInterface $response
         *
         * @return self
         */
        public function delete(string $path, string $name, $handler) : self
        {
        }
        private function route(string $httpMethod, string $path, string $name, $handler) : self
        {
        }
        /**
         * Remove an existing route.
         * Necessary before overriding a route.
         *
         * @param string $name: The name of the route.
         * @return self
         */
        public function remove(string $name) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class ServiceProvider implements \Flarum\Extend\ExtenderInterface
    {
        private $providers = [];
        /**
         * Register a service provider.
         *
         * Service providers are an advanced feature and might give access to Flarum internals that do not come with backward compatibility.
         * Please read our documentation about service providers for recommendations.
         * @see https://docs.flarum.org/extend/service-provider/
         *
         * @param string $serviceProviderClass The ::class attribute of the service provider class.
         * @return self
         */
        public function register(string $serviceProviderClass) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Settings implements \Flarum\Extend\ExtenderInterface
    {
        private $settings = [];
        private $defaults = [];
        private $lessConfigs = [];
        /**
         * Serialize a setting value to the ForumSerializer attributes.
         *
         * @param string $attributeName: The attribute name to be used in the ForumSerializer attributes array.
         * @param string $key: The key of the setting.
         * @param string|callable|null $callback: Optional callback to modify the value before serialization.
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - mixed $value: The value of the setting.
         *
         * The callable should return:
         * - mixed $value: The modified value.
         *
         * @todo remove $default in 2.0
         * @param mixed $default: Deprecated optional default serialized value. Will be run through the optional callback.
         * @return self
         */
        public function serializeToForum(string $attributeName, string $key, $callback = null, $default = null) : self
        {
        }
        /**
         * Set a default value for a setting.
         * Replaces inserting the default value with a migration.
         *
         * @param string $key: The setting key, must be unique. Namespace it with the extension ID (example: 'my-extension-id.setting_key').
         * @param mixed $value: The setting value.
         * @return self
         */
        public function default(string $key, $value) : self
        {
        }
        /**
         * Register a setting as a LESS configuration variable.
         *
         * @param string $configName: The name of the configuration variable, in hyphen case.
         * @param string $key: The key of the setting.
         * @param string|callable|null $callback: Optional callback to modify the value.
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - mixed $value: The value of the setting.
         *
         * The callable should return:
         * - mixed $value: The modified value.
         *
         * @return self
         */
        public function registerLessConfigVar(string $configName, string $key, $callback = null) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class SimpleFlarumSearch implements \Flarum\Extend\ExtenderInterface
    {
        private $fullTextGambit;
        private $gambits = [];
        private $searcher;
        private $searchMutators = [];
        /**
         * @param string $searcherClass: The ::class attribute of the Searcher you are modifying.
         *                               This searcher must extend \Flarum\Search\AbstractSearcher.
         */
        public function __construct(string $searcherClass)
        {
        }
        /**
         * Add a gambit to this searcher. Gambits are used to filter search queries.
         *
         * @param string $gambitClass: The ::class attribute of the gambit you are adding.
         *                             This gambit must extend \Flarum\Search\AbstractRegexGambit
         * @return self
         */
        public function addGambit(string $gambitClass) : self
        {
        }
        /**
         * Set the full text gambit for this searcher. The full text gambit actually executes the search.
         *
         * @param string $gambitClass: The ::class attribute of the full test gambit you are adding.
         *                             This gambit must implement \Flarum\Search\GambitInterface
         * @return self
         */
        public function setFullTextGambit(string $gambitClass) : self
        {
        }
        /**
         * Add a callback through which to run all search queries after gambits have been applied.
         *
         * @param callable|string $callback
         *
         * The callback can be a closure or an invokable class, and should accept:
         * - \Flarum\Search\SearchState $search
         * - \Flarum\Query\QueryCriteria $criteria
         *
         * The callback should return void.
         *
         * @return self
         */
        public function addSearchMutator($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Theme implements \Flarum\Extend\ExtenderInterface
    {
        private $lessImportOverrides = [];
        private $fileSourceOverrides = [];
        /**
         * This can be used to override LESS files that are imported within the code.
         * For example, core's `forum.less` file imports a `forum/DiscussionListItem.less` file.
         * The contents of this file can be overriden with this method.
         *
         * @param string $file : Relative path of the file to override, for example: `forum/Hero.less`
         * @param string $newFilePath : Absolute path of the new file.
         * @param string|null $extensionId : If overriding an extension file, specify its ID, for example: `flarum-tags`.
         * @return self
         */
        public function overrideLessImport(string $file, string $newFilePath, string $extensionId = null) : self
        {
        }
        /**
         * This method allows overriding LESS file sources.
         * For example `forum.less`, `admin.less`, `mixins.less` and `variables.less` are file sources,
         * and can therefore be overriden using this method.
         *
         * @param string $file : Name of the file to override, for example: `admin.less`
         * @param string $newFilePath : Absolute path of the new file.
         * @param string|null $extensionId : If overriding an extension file, specify its ID, for example: `flarum-tags`.
         * @return self
         */
        public function overrideFileSource(string $file, string $newFilePath, string $extensionId = null) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class ThrottleApi implements \Flarum\Extend\ExtenderInterface
    {
        private $setThrottlers = [];
        private $removeThrottlers = [];
        /**
         * Add a new throttler (or override one with the same name).
         *
         * @param string $name: The name of the throttler.
         * @param string|callable $callback
         *
         * The callable can be a closure or invokable class, and should accept:
         *   - $request: The current `\Psr\Http\Message\ServerRequestInterface` request object.
         *               `\Flarum\Http\RequestUtil::getActor($request)` can be used to get the current user.
         *               `$request->getAttribute('routeName')` can be used to get the current route.
         * Please note that every throttler runs by default on every route.
         * If you only want to throttle certain routes, you'll need to check for that inside your logic.
         *
         * The callable should return one of:
         *   - `false`: This marks the request as NOT to be throttled. It overrides all other throttlers
         *   - `true`: This marks the request as to be throttled.
         *  All other outputs will be ignored.
         *
         * @return self
         */
        public function set(string $name, $callback) : self
        {
        }
        /**
         * Remove a throttler registered with this name.
         *
         * @param string $name: The name of the throttler to remove.
         * @return self
         */
        public function remove(string $name) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class User implements \Flarum\Extend\ExtenderInterface
    {
        private $displayNameDrivers = [];
        private $groupProcessors = [];
        private $preferences = [];
        /**
         * Add a display name driver.
         *
         * @param string $identifier: Identifier for display name driver. E.g. 'username' for UserNameDriver
         * @param string $driver: ::class attribute of driver class, which must implement Flarum\User\DisplayName\DriverInterface
         * @return self
         */
        public function displayNameDriver(string $identifier, string $driver) : self
        {
        }
        /**
         * Dynamically process a user's list of groups when calculating permissions.
         * This can be used to give a user permissions for groups they aren't actually in, based on context.
         * It will not change the group badges displayed for the user.
         *
         * @param callable|string $callback
         *
         * The callable can be a closure or invokable class, and should accept:
         * - \Flarum\User\User $user: the user in question.
         * - array $groupIds: an array of ids for the groups the user belongs to.
         *
         * The callable should return:
         * - array $groupIds: an array of ids for the groups the user belongs to.
         *
         * @return self
         */
        public function permissionGroups($callback) : self
        {
        }
        /**
         * Register a new user preference.
         *
         * @param string $key
         * @param callable $transformer
         * @param mixed|null $default
         * @return self
         */
        public function registerPreference(string $key, callable $transformer = null, $default = null) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class Validator implements \Flarum\Extend\ExtenderInterface
    {
        private $configurationCallbacks = [];
        private $validator;
        /**
         * @param string $validatorClass: The ::class attribute of the validator you are modifying.
         *                                The validator should inherit from \Flarum\Foundation\AbstractValidator.
         */
        public function __construct(string $validatorClass)
        {
        }
        /**
         * Configure the validator. This is often used to adjust validation rules, but can be
         * used to make other changes to the validator as well.
         *
         * @param callable $callback
         *
         * The callback can be a closure or invokable class, and should accept:
         * - \Flarum\Foundation\AbstractValidator $flarumValidator: The Flarum validator wrapper
         * - \Illuminate\Validation\Validator $validator: The Laravel validator instance
         *
         * The callback should return void.
         *
         * @return self
         */
        public function configure($callback) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
    }
    class View implements \Flarum\Extend\ExtenderInterface, \Flarum\Extend\LifecycleInterface
    {
        private $namespaces = [];
        /**
         * Register a new namespace of Laravel views.
         *
         * Views are php files that use the Laravel Blade syntax for creation of server-side generated html.
         * Flarum core uses them for error pages, the installer, HTML emails, and the skeletons for the forum and admin sites.
         * To create and use views in your extension, you will need to put them in a folder, and register that folder as a namespace.
         *
         * Views can then be used in your extension by injecting an instance of `Illuminate\Contracts\View\Factory`,
         * and calling its `make` method. The `make` method takes the view parameter in the format NAMESPACE::VIEW_NAME.
         * You can also pass variables into a view: for more information, see https://laravel.com/api/8.x/Illuminate/View/Factory.html#method_make
         *
         * @param  string  $namespace: The name of the namespace.
         * @param  string|string[]  $hints: This is a path (or an array of paths) to the folder(s)
         *                               where view files are stored, relative to the extend.php file.
         * @return self
         */
        public function namespace(string $namespace, $hints) : self
        {
        }
        public function extend(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension = null)
        {
        }
        /**
         * @param Container $container
         * @param Extension $extension
         * @throws \Illuminate\Contracts\Container\BindingResolutionException
         */
        public function onEnable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
        /**
         * @param Container $container
         * @param Extension $extension
         * @throws \Illuminate\Contracts\Container\BindingResolutionException
         */
        public function onDisable(\Illuminate\Contracts\Container\Container $container, \Flarum\Extension\Extension $extension)
        {
        }
    }
}
namespace Flarum\Extension\Command {
    class ToggleExtension
    {
        /**
         * @var User
         */
        public $actor;
        /**
         * @var string
         */
        public $name;
        /**
         * @var bool
         */
        public $enabled;
        public function __construct(\Flarum\User\User $actor, string $name, bool $enabled)
        {
        }
    }
    class ToggleExtensionHandler
    {
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        public function __construct(\Flarum\Extension\ExtensionManager $extensions)
        {
        }
        /**
         * @throws \Flarum\User\Exception\PermissionDeniedException
         * @throws \Flarum\Extension\Exception\MissingDependenciesException
         * @throws \Flarum\Extension\Exception\DependentExtensionsException
         */
        public function handle(\Flarum\Extension\Command\ToggleExtension $command)
        {
        }
    }
}
namespace Flarum\Extension {
    class DefaultLanguagePackGuard
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings)
        {
        }
        public function handle(\Flarum\Extension\Event\Disabling $event)
        {
        }
    }
}
namespace Flarum\Extension\Event {
    class Disabled
    {
        /**
         * @var Extension
         */
        public $extension;
        /**
         * @param Extension $extension
         */
        public function __construct(\Flarum\Extension\Extension $extension)
        {
        }
    }
    class Disabling
    {
        /**
         * @var Extension
         */
        public $extension;
        /**
         * @param Extension $extension
         */
        public function __construct(\Flarum\Extension\Extension $extension)
        {
        }
    }
    class Enabled
    {
        /**
         * @var Extension
         */
        public $extension;
        /**
         * @param Extension $extension
         */
        public function __construct(\Flarum\Extension\Extension $extension)
        {
        }
    }
    class Enabling
    {
        /**
         * @var Extension
         */
        public $extension;
        /**
         * @param Extension $extension
         */
        public function __construct(\Flarum\Extension\Extension $extension)
        {
        }
    }
    class Uninstalled
    {
        /**
         * @var Extension
         */
        public $extension;
        /**
         * @param Extension $extension
         */
        public function __construct(\Flarum\Extension\Extension $extension)
        {
        }
    }
}
namespace Flarum\Extension\Exception {
    /**
     * This exception is thrown when someone attempts to disable an extension
     * that other enabled extensions depend on.
     */
    class DependentExtensionsException extends \Exception
    {
        public $extension;
        public $dependent_extensions;
        /**
         * @param $extension: The extension we are attempting to disable.
         * @param $dependent_extensions: Enabled Flarum extensions that depend on this extension.
         */
        public function __construct(\Flarum\Extension\Extension $extension, array $dependent_extensions)
        {
        }
    }
    class DependentExtensionsExceptionHandler
    {
        public function handle(\Flarum\Extension\Exception\DependentExtensionsException $e) : \Flarum\Foundation\ErrorHandling\HandledError
        {
        }
        protected function errorDetails(\Flarum\Extension\Exception\DependentExtensionsException $e) : array
        {
        }
    }
    class ExtensionBootError extends \Exception
    {
        public $extension;
        public $extender;
        public function __construct(\Flarum\Extension\Extension $extension, $extender, \Throwable $previous = null)
        {
        }
    }
    /**
     * This exception is thrown when someone attempts to enable an extension
     * whose Flarum extension dependencies are not all enabled.
     */
    class MissingDependenciesException extends \Exception
    {
        public $extension;
        public $missing_dependencies;
        /**
         * @param $extension: The extension we are attempting to enable.
         * @param $missing_dependencies: Extensions that this extension depends on, and are not enabled.
         */
        public function __construct(\Flarum\Extension\Extension $extension, array $missing_dependencies = null)
        {
        }
    }
    class MissingDependenciesExceptionHandler
    {
        public function handle(\Flarum\Extension\Exception\MissingDependenciesException $e) : \Flarum\Foundation\ErrorHandling\HandledError
        {
        }
        protected function errorDetails(\Flarum\Extension\Exception\MissingDependenciesException $e) : array
        {
        }
    }
}
namespace Flarum\Extension {
    /**
     * @property string $name
     * @property string $description
     * @property string $type
     * @property array  $keywords
     * @property string $homepage
     * @property string $time
     * @property string $license
     * @property array  $authors
     * @property array  $support
     * @property array  $require
     * @property array  $requireDev
     * @property array  $autoload
     * @property array  $autoloadDev
     * @property array  $conflict
     * @property array  $replace
     * @property array  $provide
     * @property array  $suggest
     * @property array  $extra
     */
    class Extension implements \Illuminate\Contracts\Support\Arrayable
    {
        const LOGO_MIMETYPES = ['svg' => 'image/svg+xml', 'png' => 'image/png', 'jpeg' => 'image/jpeg', 'jpg' => 'image/jpeg'];
        /**
         * Unique Id of the extension.
         *
         * @info    Identical to the directory in the extensions directory.
         * @example flarum-suspend
         *
         * @var string
         */
        protected $id;
        /**
         * The directory of this extension.
         *
         * @var string
         */
        protected $path;
        /**
         * Composer json of the package.
         *
         * @var array
         */
        protected $composerJson;
        /**
         * The IDs of all Flarum extensions that this extension depends on.
         *
         * @var string[]
         */
        protected $extensionDependencyIds;
        /**
         * The IDs of all Flarum extensions that this extension should be booted after
         * if enabled.
         *
         * @var string[]
         */
        protected $optionalDependencyIds;
        /**
         * Whether the extension is installed.
         *
         * @var bool
         */
        protected $installed = true;
        /**
         * The installed version of the extension.
         *
         * @var string
         */
        protected $version;
        /**
         * @param       $path
         * @param array $composerJson
         */
        public function __construct($path, $composerJson)
        {
        }
        protected static function nameToId($name)
        {
        }
        /**
         * Assigns the id for the extension used globally.
         */
        protected function assignId()
        {
        }
        /**
         * @internal
         */
        public function extend(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __get($name)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function __isset($name)
        {
        }
        /**
         * Dot notation getter for composer.json attributes.
         *
         * @see https://laravel.com/docs/8.x/helpers#arrays
         *
         * @param $name
         * @return mixed
         */
        public function composerJsonAttribute($name)
        {
        }
        /**
         * @param bool $installed
         * @return Extension
         *
         * @internal
         */
        public function setInstalled($installed)
        {
        }
        /**
         * @return bool
         */
        public function isInstalled()
        {
        }
        /**
         * @param string $version
         * @return Extension
         *
         * @internal
         */
        public function setVersion($version)
        {
        }
        /**
         * Get the list of flarum extensions that this extension depends on.
         *
         * @param array $extensionSet: An associative array where keys are the composer package names
         *                             of installed extensions. Used to figure out which dependencies
         *                             are flarum extensions.
         * @param array $enabledIds:   An associative array where keys are the composer package names
         *                             of enabled extensions. Used to figure out optional dependencies.
         *
         * @internal
         */
        public function calculateDependencies($extensionSet, $enabledIds)
        {
        }
        /**
         * @return string
         */
        public function getVersion()
        {
        }
        /**
         * Loads the icon information from the composer.json.
         *
         * @return array|null
         */
        public function getIcon()
        {
        }
        public function getIconStyles() : string
        {
        }
        /**
         * @internal
         */
        public function enable(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * @internal
         */
        public function disable(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * The raw path of the directory under extensions.
         *
         * @return string
         */
        public function getId()
        {
        }
        /**
         * @return string
         */
        public function getTitle()
        {
        }
        /**
         * @return string
         */
        public function getPath()
        {
        }
        /**
         * The IDs of all Flarum extensions that this extension depends on.
         *
         * @return array
         */
        public function getExtensionDependencyIds() : array
        {
        }
        /**
         * The IDs of all Flarum extensions that this extension should be booted after
         * if enabled.
         *
         * @return array
         */
        public function getOptionalDependencyIds() : array
        {
        }
        private function getExtenders() : array
        {
        }
        /**
         * @return LifecycleInterface[]
         */
        private function getLifecycleExtenders() : array
        {
        }
        private function getExtenderFile() : ?string
        {
        }
        /**
         * Compile a list of links for this extension.
         */
        public function getLinks()
        {
        }
        /**
         * Tests whether the extension has assets.
         *
         * @return bool
         */
        public function hasAssets()
        {
        }
        /**
         * @internal
         */
        public function copyAssetsTo(\Illuminate\Contracts\Filesystem\Filesystem $target)
        {
        }
        /**
         * Tests whether the extension has migrations.
         *
         * @return bool
         */
        public function hasMigrations()
        {
        }
        /**
         * @internal
         */
        public function migrate(\Flarum\Database\Migrator $migrator, $direction = 'up')
        {
        }
        /**
         * Generates an array result for the object.
         *
         * @return array
         */
        public function toArray()
        {
        }
        /**
         * Gets the rendered contents of the extension README file as a HTML string.
         *
         * @return string|null
         */
        public function getReadme() : ?string
        {
        }
    }
    class ExtensionManager
    {
        protected $config;
        /**
         * @var Paths
         */
        protected $paths;
        protected $container;
        protected $migrator;
        /**
         * @var Dispatcher
         */
        protected $dispatcher;
        /**
         * @var Filesystem
         */
        protected $filesystem;
        /**
         * @var Collection|null
         */
        protected $extensions;
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $config, \Flarum\Foundation\Paths $paths, \Illuminate\Contracts\Container\Container $container, \Flarum\Database\Migrator $migrator, \Illuminate\Contracts\Events\Dispatcher $dispatcher, \Illuminate\Filesystem\Filesystem $filesystem)
        {
        }
        /**
         * @return Collection
         */
        public function getExtensions()
        {
        }
        /**
         * Loads an Extension with all information.
         *
         * @param string $name
         * @return Extension|null
         */
        public function getExtension($name)
        {
        }
        /**
         * Enables the extension.
         *
         * @param string $name
         *
         * @internal
         */
        public function enable($name)
        {
        }
        /**
         * Disables an extension.
         *
         * @param string $name
         *
         * @internal
         */
        public function disable($name)
        {
        }
        /**
         * Uninstalls an extension.
         *
         * @param string $name
         * @internal
         */
        public function uninstall($name)
        {
        }
        /**
         * Copy the assets from an extension's assets directory into public view.
         *
         * @param Extension $extension
         */
        protected function publishAssets(\Flarum\Extension\Extension $extension)
        {
        }
        /**
         * Delete an extension's assets from public view.
         *
         * @param Extension $extension
         */
        protected function unpublishAssets(\Flarum\Extension\Extension $extension)
        {
        }
        /**
         * Get the path to an extension's published asset.
         *
         * @param Extension $extension
         * @param string    $path
         * @return string
         */
        public function getAsset(\Flarum\Extension\Extension $extension, $path)
        {
        }
        /**
         * Get an instance of the assets filesystem.
         * This is resolved dynamically because Flarum's filesystem configuration
         * might not be booted yet when the ExtensionManager singleton initializes.
         */
        protected function getAssetsFilesystem() : \Illuminate\Contracts\Filesystem\Cloud
        {
        }
        /**
         * Runs the database migrations for the extension.
         *
         * @param Extension $extension
         * @param string $direction
         * @return void
         *
         * @internal
         */
        public function migrate(\Flarum\Extension\Extension $extension, $direction = 'up')
        {
        }
        /**
         * Runs the database migrations to reset the database to its old state.
         *
         * @param Extension $extension
         * @return array Notes from the migrator.
         *
         * @internal
         */
        public function migrateDown(\Flarum\Extension\Extension $extension)
        {
        }
        /**
         * The database migrator.
         *
         * @return Migrator
         */
        public function getMigrator()
        {
        }
        /**
         * Get only enabled extensions.
         *
         * @return array|Extension[]
         */
        public function getEnabledExtensions()
        {
        }
        /**
         * Call on all enabled extensions to extend the Flarum application.
         *
         * @param Container $container
         */
        public function extend(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * The id's of the enabled extensions.
         *
         * @return array
         */
        public function getEnabled()
        {
        }
        /**
         * Persist the currently enabled extensions.
         *
         * @param array $enabledExtensions
         */
        protected function setEnabledExtensions(array $enabledExtensions)
        {
        }
        /**
         * Whether the extension is enabled.
         *
         * @param $extension
         * @return bool
         */
        public function isEnabled($extension)
        {
        }
        /**
         * Returns the titles of the extensions passed.
         *
         * @param array $exts
         * @return string[]
         */
        public static function pluckTitles(array $exts)
        {
        }
        /**
         * Sort a list of extensions so that they are properly resolved in respect to order.
         * Effectively just topological sorting.
         *
         * @param Extension[] $extensionList
         *
         * @return array with 2 keys: 'valid' points to an ordered array of \Flarum\Extension\Extension
         *                            'missingDependencies' points to an associative array of extensions that could not be resolved due
         *                                to missing dependencies, in the format extension id => array of missing dependency IDs.
         *                            'circularDependencies' points to an array of extensions ids of extensions
         *                                that cannot be processed due to circular dependencies
         *
         * @internal
         */
        public static function resolveExtensionOrder($extensionList)
        {
        }
    }
    class ExtensionServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
    }
}
namespace Flarum\Filesystem {
    interface DriverInterface
    {
        /**
         * Construct a Laravel Cloud filesystem for this filesystem driver.
         * Settings and configuration can either be pulled from the Flarum settings repository
         * or the config.php file.
         *
         * Typically, this is done by wrapping a Flysystem adapter in Laravel's
         * `Illuminate\Filesystem\FilesystemAdapter` class.
         * You should ensure that the Flysystem adapter you use has a `getUrl` method.
         * If it doesn't, you should create a subclass implementing that method.
         * Otherwise, this driver won't work for public-facing disks
         * like `flarum-assets` or `flarum-avatars`.
         *
         * @param string $diskName: The name of a disk this driver is being used for.
         *                   This is generally used to locate disk-specific settings.
         * @param SettingsRepositoryInterface $settings: An instance of the Flarum settings repository.
         * @param Config $config: An instance of the wrapper class around `config.php`.
         * @param array $localConfig: The configuration array that would have been used
         *                            if this disk were using the 'local' filesystem driver.
         *                            Some of these settings might be useful (e.g. visibility, )
         */
        public function build(string $diskName, \Flarum\Settings\SettingsRepositoryInterface $settings, \Flarum\Foundation\Config $config, array $localConfig) : \Illuminate\Contracts\Filesystem\Cloud;
    }
    class FilesystemManager extends \Illuminate\Filesystem\FilesystemManager
    {
        protected $diskLocalConfig = [];
        protected $drivers = [];
        public function __construct(\Illuminate\Contracts\Container\Container $app, array $diskLocalConfig, array $drivers)
        {
        }
        /**
         * @inheritDoc
         */
        protected function resolve($name, $config = null) : \Illuminate\Contracts\Filesystem\Filesystem
        {
        }
        /**
         * @return string|DriverInterface
         */
        protected function getDriver(string $name)
        {
        }
        protected function getLocalConfig(string $name) : array
        {
        }
    }
    class FilesystemServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
    }
}
namespace Flarum\Filter {
    class FilterServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * Register the service provider.
         *
         * @return void
         */
        public function register()
        {
        }
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
}
namespace Flarum\Query {
    abstract class AbstractQueryState
    {
        /**
         * @var Builder
         */
        protected $query;
        /**
         * @var User
         */
        protected $actor;
        /**
         * @var mixed
         */
        protected $defaultSort = [];
        /**
         * @param Builder $query
         * @param User $actor
         */
        public function __construct(\Illuminate\Database\Query\Builder $query, \Flarum\User\User $actor, $defaultSort = [])
        {
        }
        /**
         * Get the query builder for the search results query.
         *
         * @return Builder
         */
        public function getQuery()
        {
        }
        /**
         * Get the user who is performing the search.
         *
         * @return User
         */
        public function getActor()
        {
        }
        /**
         * Get the default sort order for the search.
         *
         * @return array
         */
        public function getDefaultSort()
        {
        }
        /**
         * Set the default sort order for the search. This will only be applied if
         * a sort order has not been specified in the search criteria.
         *
         * @param mixed $defaultSort An array of sort-order pairs, where the column
         *     is the key, and the order is the value. The order may be 'asc',
         *     'desc', or an array of IDs to order by.
         *     Alternatively, a callable may be used.
         * @return mixed
         */
        public function setDefaultSort($defaultSort)
        {
        }
    }
}
namespace Flarum\Filter {
    class FilterState extends \Flarum\Query\AbstractQueryState
    {
        /**
         * @var FilterInterface[]
         */
        protected $activeFilters = [];
        /**
         * Get a list of the filters that are active.
         *
         * @return FilterInterface[]
         */
        public function getActiveFilters()
        {
        }
        /**
         * Add a filter as being active.
         *
         * @param FilterInterface $filter
         * @return void
         */
        public function addActiveFilter(\Flarum\Filter\FilterInterface $filter)
        {
        }
    }
}
namespace Flarum\Formatter {
    class Formatter
    {
        protected $configurationCallbacks = [];
        protected $parsingCallbacks = [];
        protected $unparsingCallbacks = [];
        protected $renderingCallbacks = [];
        /**
         * @var Repository
         */
        protected $cache;
        /**
         * @var string
         */
        protected $cacheDir;
        /**
         * @param Repository $cache
         * @param string $cacheDir
         */
        public function __construct(\Illuminate\Contracts\Cache\Repository $cache, $cacheDir)
        {
        }
        /**
         * @internal
         */
        public function addConfigurationCallback($callback)
        {
        }
        /**
         * @internal
         */
        public function addParsingCallback($callback)
        {
        }
        /**
         * @internal
         */
        public function addUnparsingCallback($callback)
        {
        }
        /**
         * @internal
         */
        public function addRenderingCallback($callback)
        {
        }
        /**
         * Parse text.
         *
         * @param string $text
         * @param mixed $context
         * @return string
         */
        public function parse($text, $context = null)
        {
        }
        /**
         * Render parsed XML.
         *
         * @param string $xml
         * @param mixed $context
         * @param ServerRequestInterface|null $request
         * @return string
         */
        public function render($xml, $context = null, \Psr\Http\Message\ServerRequestInterface $request = null)
        {
        }
        /**
         * Unparse XML.
         *
         * @param string $xml
         * @param mixed $context
         * @return string
         */
        public function unparse($xml, $context = null)
        {
        }
        /**
         * Flush the cache so that the formatter components are regenerated.
         */
        public function flush()
        {
        }
        /**
         * @return Configurator
         */
        protected function getConfigurator()
        {
        }
        /**
         * @param Configurator $configurator
         */
        protected function configureExternalLinks(\s9e\TextFormatter\Configurator $configurator)
        {
        }
        /**
         * Get a TextFormatter component.
         *
         * @param string $name "renderer" or "parser" or "js"
         * @return mixed
         */
        protected function getComponent($name)
        {
        }
        /**
         * Get the parser.
         *
         * @param mixed $context
         * @return \s9e\TextFormatter\Parser
         */
        protected function getParser($context = null)
        {
        }
        /**
         * Get the renderer.
         *
         * @return \s9e\TextFormatter\Renderer
         */
        protected function getRenderer()
        {
        }
        /**
         * Get the formatter JavaScript.
         *
         * @return string
         */
        public function getJs()
        {
        }
    }
    class FormatterServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
    }
}
namespace Flarum\Forum\Auth {
    class Registration
    {
        /**
         * @var array
         */
        protected $provided = [];
        /**
         * @var array
         */
        protected $suggested = [];
        /**
         * @var mixed
         */
        protected $payload;
        /**
         * @return array
         */
        public function getProvided() : array
        {
        }
        /**
         * @return array
         */
        public function getSuggested() : array
        {
        }
        /**
         * @return mixed
         */
        public function getPayload()
        {
        }
        /**
         * @param string $key
         * @param mixed $value
         * @return $this
         */
        public function provide(string $key, $value) : self
        {
        }
        /**
         * @param string $email
         * @return $this
         */
        public function provideTrustedEmail(string $email) : self
        {
        }
        /**
         * @param string $url
         * @return $this
         */
        public function provideAvatar(string $url) : self
        {
        }
        /**
         * @param string $key
         * @param mixed $value
         * @return $this
         */
        public function suggest(string $key, $value) : self
        {
        }
        /**
         * @param string $username
         * @return $this
         */
        public function suggestUsername(string $username) : self
        {
        }
        /**
         * @param string $email
         * @return $this
         */
        public function suggestEmail(string $email) : self
        {
        }
        /**
         * @param mixed $payload
         * @return $this
         */
        public function setPayload($payload) : self
        {
        }
    }
    class ResponseFactory
    {
        /**
         * @var Rememberer
         */
        protected $rememberer;
        /**
         * @param Rememberer $rememberer
         */
        public function __construct(\Flarum\Http\Rememberer $rememberer)
        {
        }
        public function make(string $provider, string $identifier, callable $configureRegistration) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function makeResponse(array $payload) : \Laminas\Diactoros\Response\HtmlResponse
        {
        }
        private function makeLoggedInResponse(\Flarum\User\User $user)
        {
        }
    }
}
namespace Flarum\Forum\Content {
    class AssertRegistered
    {
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class Discussion
    {
        /**
         * @var Client
         */
        protected $api;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @param Client $api
         * @param UrlGenerator $url
         * @param Factory $view
         */
        public function __construct(\Flarum\Api\Client $api, \Flarum\Http\UrlGenerator $url, \Illuminate\Contracts\View\Factory $view)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * Get the result of an API request to show a discussion.
         *
         * @throws RouteNotFoundException
         */
        protected function getApiDocument(\Psr\Http\Message\ServerRequestInterface $request, string $id, array $params)
        {
        }
    }
    class Index
    {
        /**
         * @var Client
         */
        protected $api;
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param Client $api
         * @param Factory $view
         * @param SettingsRepositoryInterface $settings
         * @param UrlGenerator $url
         * @param TranslatorInterface $translator
         */
        public function __construct(\Flarum\Api\Client $api, \Illuminate\Contracts\View\Factory $view, \Flarum\Settings\SettingsRepositoryInterface $settings, \Flarum\Http\UrlGenerator $url, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * Get a map of sort query param values and their API sort params.
         *
         * @return array
         */
        private function getSortMap()
        {
        }
        /**
         * Get the result of an API request to list discussions.
         *
         * @param Request $request
         * @param array $params
         * @return object
         */
        protected function getApiDocument(\Psr\Http\Message\ServerRequestInterface $request, array $params)
        {
        }
    }
    class User
    {
        /**
         * @var Client
         */
        protected $api;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param Client $api
         * @param UrlGenerator $url
         */
        public function __construct(\Flarum\Api\Client $api, \Flarum\Http\UrlGenerator $url)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * Get the result of an API request to show a user.
         *
         * @throws ModelNotFoundException
         */
        protected function getApiDocument(\Psr\Http\Message\ServerRequestInterface $request, string $username)
        {
        }
    }
}
namespace Flarum\Forum\Controller {
    class ConfirmEmailController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Dispatcher
         */
        protected $bus;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @param Dispatcher $bus
         * @param UrlGenerator $url
         * @param SessionAuthenticator $authenticator
         */
        public function __construct(\Illuminate\Contracts\Bus\Dispatcher $bus, \Flarum\Http\UrlGenerator $url, \Flarum\Http\SessionAuthenticator $authenticator)
        {
        }
        /**
         * @param Request $request
         * @return ResponseInterface
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Http\Controller {
    abstract class AbstractHtmlController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @param Request $request
         * @return HtmlResponse
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        /**
         * @param Request $request
         * @return string|Renderable
         */
        protected abstract function render(\Psr\Http\Message\ServerRequestInterface $request);
    }
}
namespace Flarum\Forum\Controller {
    class ConfirmEmailViewController extends \Flarum\Http\Controller\AbstractHtmlController
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @param Factory $view
         */
        public function __construct(\Illuminate\Contracts\View\Factory $view)
        {
        }
        /**
         * @param Request $request
         * @return \Illuminate\Contracts\View\View
         */
        public function render(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class LogInController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @var Client
         */
        protected $apiClient;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * @var Rememberer
         */
        protected $rememberer;
        /**
         * @param \Flarum\User\UserRepository $users
         * @param Client $apiClient
         * @param SessionAuthenticator $authenticator
         * @param Rememberer $rememberer
         */
        public function __construct(\Flarum\User\UserRepository $users, \Flarum\Api\Client $apiClient, \Flarum\Http\SessionAuthenticator $authenticator, \Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Http\Rememberer $rememberer)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class LogOutController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @var Rememberer
         */
        protected $rememberer;
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @param Dispatcher $events
         * @param SessionAuthenticator $authenticator
         * @param Rememberer $rememberer
         * @param Factory $view
         * @param UrlGenerator $url
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Http\SessionAuthenticator $authenticator, \Flarum\Http\Rememberer $rememberer, \Illuminate\Contracts\View\Factory $view, \Flarum\Http\UrlGenerator $url)
        {
        }
        /**
         * @param Request $request
         * @return ResponseInterface
         * @throws TokenMismatchException
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class RegisterController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Client
         */
        protected $api;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @var Rememberer
         */
        protected $rememberer;
        /**
         * @param Client $api
         * @param SessionAuthenticator $authenticator
         * @param Rememberer $rememberer
         */
        public function __construct(\Flarum\Api\Client $api, \Flarum\Http\SessionAuthenticator $authenticator, \Flarum\Http\Rememberer $rememberer)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ResetPasswordController extends \Flarum\Http\Controller\AbstractHtmlController
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @param Factory $view
         */
        public function __construct(\Illuminate\Contracts\View\Factory $view)
        {
        }
        /**
         * @param Request $request
         * @return \Illuminate\Contracts\View\View
         * @throws \Flarum\User\Exception\InvalidConfirmationTokenException
         */
        public function render(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class SavePasswordController implements \Psr\Http\Server\RequestHandlerInterface
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var \Flarum\User\UserValidator
         */
        protected $validator;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @var Factory
         */
        protected $validatorFactory;
        /**
         * @param UrlGenerator $url
         * @param SessionAuthenticator $authenticator
         * @param UserValidator $validator
         * @param Factory $validatorFactory
         */
        public function __construct(\Flarum\Http\UrlGenerator $url, \Flarum\Http\SessionAuthenticator $authenticator, \Flarum\User\UserValidator $validator, \Illuminate\Contracts\Validation\Factory $validatorFactory, \Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
        /**
         * @param Request $request
         * @return ResponseInterface
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Forum {
    class ForumServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        public function boot(\Illuminate\Contracts\Container\Container $container, \Illuminate\Contracts\Events\Dispatcher $events, \Illuminate\Contracts\View\Factory $view)
        {
        }
        /**
         * Populate the forum client routes.
         *
         * @param RouteCollection $routes
         * @param Container       $container
         */
        protected function populateRoutes(\Flarum\Http\RouteCollection $routes, \Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * Determine the default route.
         *
         * @param RouteCollection $routes
         * @param Container       $container
         */
        protected function setDefaultRoute(\Flarum\Http\RouteCollection $routes, \Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    /**
     * @internal
     */
    class ValidateCustomLess
    {
        /**
         * @var Assets
         */
        protected $assets;
        /**
         * @var LocaleManager
         */
        protected $locales;
        /**
         * @var Container
         */
        protected $container;
        /**
         * @var array
         */
        protected $customLessSettings;
        public function __construct(\Flarum\Frontend\Assets $assets, \Flarum\Locale\LocaleManager $locales, \Illuminate\Contracts\Container\Container $container, array $customLessSettings = [])
        {
        }
        public function whenSettingsSaving(\Flarum\Settings\Event\Saving $event)
        {
        }
        public function whenSettingsSaved(\Flarum\Settings\Event\Saved $event)
        {
        }
        /**
         * @param Saved|Saving $event
         * @return bool
         */
        protected function hasDirtyCustomLessSettings($event) : bool
        {
        }
    }
}
namespace Flarum\Foundation {
    interface AppInterface
    {
        /**
         * @return \Psr\Http\Server\RequestHandlerInterface
         */
        public function getRequestHandler();
        /**
         * @return \Symfony\Component\Console\Command\Command[]
         */
        public function getConsoleCommands();
    }
    class Application
    {
        /**
         * The Flarum version.
         *
         * @var string
         */
        const VERSION = '1.2.0-dev';
        /**
         * The IoC container for the Flarum application.
         *
         * @var Container
         */
        private $container;
        /**
         * The paths for the Flarum installation.
         *
         * @var Paths
         */
        protected $paths;
        /**
         * Indicates if the application has "booted".
         *
         * @var bool
         */
        protected $booted = false;
        /**
         * The array of booting callbacks.
         *
         * @var array
         */
        protected $bootingCallbacks = [];
        /**
         * The array of booted callbacks.
         *
         * @var array
         */
        protected $bootedCallbacks = [];
        /**
         * All of the registered service providers.
         *
         * @var array
         */
        protected $serviceProviders = [];
        /**
         * The names of the loaded service providers.
         *
         * @var array
         */
        protected $loadedProviders = [];
        /**
         * Create a new Flarum application instance.
         *
         * @param Container $container
         * @param Paths $paths
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Foundation\Paths $paths)
        {
        }
        /**
         * @param string $key
         * @param mixed $default
         * @return mixed
         */
        public function config($key, $default = null)
        {
        }
        /**
         * Check if Flarum is in debug mode.
         *
         * @return bool
         */
        public function inDebugMode()
        {
        }
        /**
         * Get the URL to the Flarum installation.
         *
         * @param string $path
         * @return string
         */
        public function url($path = null)
        {
        }
        /**
         * Register the basic bindings into the container.
         */
        protected function registerBaseBindings()
        {
        }
        /**
         * Register all of the base service providers.
         */
        protected function registerBaseServiceProviders()
        {
        }
        /**
         * Register a service provider with the application.
         *
         * @param ServiceProvider|string $provider
         * @param array $options
         * @param bool $force
         * @return ServiceProvider
         */
        public function register($provider, $options = [], $force = false)
        {
        }
        /**
         * Get the registered service provider instance if it exists.
         *
         * @param ServiceProvider|string $provider
         * @return ServiceProvider|null
         */
        public function getProvider($provider)
        {
        }
        /**
         * Resolve a service provider instance from the class name.
         *
         * @param string $provider
         * @return ServiceProvider
         */
        public function resolveProviderClass($provider)
        {
        }
        /**
         * Mark the given provider as registered.
         *
         * @param ServiceProvider $provider
         * @return void
         */
        protected function markAsRegistered($provider)
        {
        }
        /**
         * Determine if the application has booted.
         *
         * @return bool
         */
        public function isBooted()
        {
        }
        /**
         * Boot the application's service providers.
         *
         * @return void
         */
        public function boot()
        {
        }
        /**
         * Boot the given service provider.
         *
         * @param ServiceProvider $provider
         * @return mixed
         */
        protected function bootProvider(\Illuminate\Support\ServiceProvider $provider)
        {
        }
        /**
         * Register a new boot listener.
         *
         * @param mixed $callback
         * @return void
         */
        public function booting($callback)
        {
        }
        /**
         * Register a new "booted" listener.
         *
         * @param mixed $callback
         * @return void
         */
        public function booted($callback)
        {
        }
        /**
         * Call the booting callbacks for the application.
         *
         * @param array $callbacks
         * @return void
         */
        protected function fireAppCallbacks(array $callbacks)
        {
        }
        /**
         * Register the core class aliases in the container.
         */
        public function registerCoreContainerAliases()
        {
        }
    }
    class Config implements \ArrayAccess
    {
        private $data;
        public function __construct(array $data)
        {
        }
        public function url() : \Psr\Http\Message\UriInterface
        {
        }
        public function inDebugMode() : bool
        {
        }
        public function inMaintenanceMode() : bool
        {
        }
        private function requireKeys(...$keys)
        {
        }
        public function offsetGet($offset)
        {
        }
        public function offsetExists($offset)
        {
        }
        public function offsetSet($offset, $value)
        {
        }
        public function offsetUnset($offset)
        {
        }
    }
}
namespace Flarum\Foundation\Console {
    class AssetsPublishCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var Container
         */
        protected $container;
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @param Container $container
         * @param Paths $paths
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Foundation\Paths $paths)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
    }
    class CacheClearCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var Store
         */
        protected $cache;
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @param Store $cache
         * @param Paths $paths
         */
        public function __construct(\Illuminate\Contracts\Cache\Store $cache, \Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Foundation\Paths $paths)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
    }
    class InfoCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var ExtensionManager
         */
        protected $extensions;
        /**
         * @var Config
         */
        protected $config;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var ConnectionInterface
         */
        protected $db;
        /**
         * @var Queue
         */
        private $queue;
        public function __construct(\Flarum\Extension\ExtensionManager $extensions, \Flarum\Foundation\Config $config, \Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Database\ConnectionInterface $db, \Illuminate\Contracts\Queue\Queue $queue)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
        private function getExtensionTable()
        {
        }
        /**
         * Try to detect a package's exact version.
         *
         * If the package seems to be a Git version, we extract the currently
         * checked out commit using the command line.
         */
        private function findPackageVersion(string $path, string $fallback = null) : ?string
        {
        }
        private function identifyQueueDriver() : string
        {
        }
        private function identifyDatabaseVersion() : string
        {
        }
    }
}
namespace Flarum\Foundation {
    class ContainerUtil
    {
        /**
         * Wraps a callback so that string-based invokable classes get resolved only when actually used.
         *
         * @internal Backwards compatability not guaranteed.
         *
         * @param callable|string $callback: A callable, global function, or a ::class attribute of an invokable class
         * @param Container $container
         */
        public static function wrapCallback($callback, \Illuminate\Contracts\Container\Container $container)
        {
        }
    }
}
namespace Flarum\Foundation\ErrorHandling\ExceptionHandler {
    class IlluminateValidationExceptionHandler
    {
        public function handle(\Illuminate\Validation\ValidationException $e) : \Flarum\Foundation\ErrorHandling\HandledError
        {
        }
        protected function errorDetails(\Illuminate\Validation\ValidationException $e) : array
        {
        }
    }
    class ValidationExceptionHandler
    {
        public function handle(\Flarum\Foundation\ValidationException $e)
        {
        }
        private function buildDetails(array $messages, $pointer) : array
        {
        }
    }
}
namespace Flarum\Foundation\ErrorHandling {
    /**
     * An error that was caught / interpreted by Flarum's error handling stack.
     *
     * Most importantly, such an error has a "type" (which is used to look up
     * translated error messages and views to render pretty HTML pages) and an
     * associated HTTP status code for used in rendering HTTP error responses.
     */
    class HandledError
    {
        private $error;
        private $type;
        private $statusCode;
        private $details = [];
        public static function unknown(\Throwable $error)
        {
        }
        public function __construct(\Throwable $error, $type, $statusCode)
        {
        }
        public function withDetails(array $details) : self
        {
        }
        public function getException() : \Throwable
        {
        }
        public function getType() : string
        {
        }
        public function getStatusCode() : int
        {
        }
        public function shouldBeReported() : bool
        {
        }
        public function getDetails() : array
        {
        }
        public function hasDetails() : bool
        {
        }
    }
    interface HttpFormatter
    {
        /**
         * Create an HTTP Response to represent the error we are handling.
         *
         * This method receives the error that was caught by Flarum's error handling
         * stack, along with the current HTTP request instance. It should return an
         * HTTP response that explains or represents what went wrong.
         *
         * @param HandledError $error
         * @param Request $request
         * @return Response
         */
        public function format(\Flarum\Foundation\ErrorHandling\HandledError $error, \Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface;
    }
    /**
     * A formatter to render exceptions as valid {JSON:API} error object.
     *
     * See https://jsonapi.org/format/1.0/#errors.
     */
    class JsonApiFormatter implements \Flarum\Foundation\ErrorHandling\HttpFormatter
    {
        private $includeTrace;
        public function __construct($includeTrace = false)
        {
        }
        public function format(\Flarum\Foundation\ErrorHandling\HandledError $error, \Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function default(\Flarum\Foundation\ErrorHandling\HandledError $error) : array
        {
        }
        private function withDetails(\Flarum\Foundation\ErrorHandling\HandledError $error) : array
        {
        }
    }
    interface Reporter
    {
        /**
         * Report an error that Flarum was not able to handle to a backend.
         *
         * @param Throwable $error
         * @return void
         */
        public function report(\Throwable $error);
    }
    /**
     * Log caught exceptions to a PSR-3 logger instance.
     */
    class LogReporter implements \Flarum\Foundation\ErrorHandling\Reporter
    {
        /**
         * @var LoggerInterface
         */
        protected $logger;
        public function __construct(\Psr\Log\LoggerInterface $logger)
        {
        }
        public function report(\Throwable $error)
        {
        }
    }
    /**
     * Flarum's central registry of known error types.
     *
     * It knows how to deal with errors raised both within Flarum's core and outside
     * of it, map them to error "types" and how to determine appropriate HTTP status
     * codes for them.
     */
    class Registry
    {
        private $statusMap;
        private $classMap;
        private $handlerMap;
        public function __construct(array $statusMap, array $classMap, array $handlerMap)
        {
        }
        /**
         * Map exceptions to handled errors.
         *
         * This can map internal ({@see \Flarum\Foundation\KnownError}) as well as
         * external exceptions (any classes inheriting from \Throwable) to instances
         * of {@see \Flarum\Foundation\ErrorHandling\HandledError}.
         *
         * Even for unknown exceptions, a generic fallback will always be returned.
         *
         * @param Throwable $error
         * @return HandledError
         */
        public function handle(\Throwable $error) : \Flarum\Foundation\ErrorHandling\HandledError
        {
        }
        private function handleKnownTypes(\Throwable $error) : ?\Flarum\Foundation\ErrorHandling\HandledError
        {
        }
        private function handleCustomTypes(\Throwable $error) : ?\Flarum\Foundation\ErrorHandling\HandledError
        {
        }
    }
    /**
     * A formatter for turning caught exceptions into "pretty" HTML error pages.
     *
     * For certain known error types, we display pages with dedicated information
     * relevant to this class of error, e.g. a page with a search form for HTTP 404
     * "Not Found" errors. We look for templates in the `views/error` directory.
     *
     * If no specific template exists, a generic "Something went wrong" page will be
     * displayed, optionally enriched with a more specific error message if found in
     * the translation files.
     */
    class ViewFormatter implements \Flarum\Foundation\ErrorHandling\HttpFormatter
    {
        /**
         * @var ViewFactory
         */
        protected $view;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        public function __construct(\Illuminate\Contracts\View\Factory $view, \Symfony\Contracts\Translation\TranslatorInterface $translator, \Flarum\Settings\SettingsRepositoryInterface $settings)
        {
        }
        public function format(\Flarum\Foundation\ErrorHandling\HandledError $error, \Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        const ERRORS_WITH_VIEWS = ['csrf_token_mismatch', 'not_found'];
        private function determineView(\Flarum\Foundation\ErrorHandling\HandledError $error) : string
        {
        }
        private function getMessage(\Flarum\Foundation\ErrorHandling\HandledError $error)
        {
        }
        private function getTranslationIfExists(string $errorType)
        {
        }
    }
    /**
     * Handle errors using the Whoops error handler for debugging.
     *
     * Proper status codes for all known error types are returned. In addition,
     * content negotiation is performed to return proper responses in various
     * environments such as HTML frontends or API backends.
     *
     * Should only be used in debug mode (because Whoops may expose sensitive data).
     */
    class WhoopsFormatter implements \Flarum\Foundation\ErrorHandling\HttpFormatter
    {
        public function format(\Flarum\Foundation\ErrorHandling\HandledError $error, \Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Foundation {
    class ErrorServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        public function register()
        {
        }
    }
}
namespace Flarum\Foundation\Event {
    class ClearingCache
    {
    }
}
namespace Flarum\Foundation {
    class InstalledApp implements \Flarum\Foundation\AppInterface
    {
        /**
         * @var Container
         */
        protected $container;
        /**
         * @var Config
         */
        protected $config;
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Foundation\Config $config)
        {
        }
        public function getContainer()
        {
        }
        /**
         * @return \Psr\Http\Server\RequestHandlerInterface
         */
        public function getRequestHandler()
        {
        }
        protected function needsUpdate() : bool
        {
        }
        /**
         * @return \Psr\Http\Server\RequestHandlerInterface
         */
        protected function getUpdaterHandler()
        {
        }
        protected function basePath() : string
        {
        }
        protected function subPath($pathName) : string
        {
        }
        /**
         * @return \Symfony\Component\Console\Command\Command[]
         */
        public function getConsoleCommands()
        {
        }
    }
    interface SiteInterface
    {
        /**
         * Create and boot a Flarum application instance.
         *
         * @return AppInterface
         */
        public function bootApp() : \Flarum\Foundation\AppInterface;
    }
    class InstalledSite implements \Flarum\Foundation\SiteInterface
    {
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @var Config
         */
        protected $config;
        /**
         * @var \Flarum\Extend\ExtenderInterface[]
         */
        protected $extenders = [];
        public function __construct(\Flarum\Foundation\Paths $paths, \Flarum\Foundation\Config $config)
        {
        }
        /**
         * Create and boot a Flarum application instance.
         *
         * @return InstalledApp
         */
        public function bootApp() : \Flarum\Foundation\AppInterface
        {
        }
        /**
         * @param \Flarum\Extend\ExtenderInterface[] $extenders
         * @return InstalledSite
         */
        public function extendWith(array $extenders) : self
        {
        }
        protected function bootLaravel() : \Illuminate\Contracts\Container\Container
        {
        }
        /**
         * @return ConfigRepository
         */
        protected function getIlluminateConfig()
        {
        }
        protected function registerLogger(\Illuminate\Contracts\Container\Container $container)
        {
        }
        protected function registerCache(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    class MaintenanceModeHandler implements \Psr\Http\Server\RequestHandlerInterface
    {
        const MESSAGE = 'Currently down for maintenance. Please come back later.';
        /**
         * Handle the request and return a response.
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function isApiRequest(\Psr\Http\Message\ServerRequestInterface $request) : bool
        {
        }
        private function apiResponse() : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * @property-read string base
     * @property-read string public
     * @property-read string storage
     * @property-read string vendor
     */
    class Paths
    {
        private $paths;
        public function __construct(array $paths)
        {
        }
        public function __get($name) : ?string
        {
        }
    }
    class Site
    {
        /**
         * @param array $paths
         * @return SiteInterface
         */
        public static function fromPaths(array $paths)
        {
        }
        protected static function hasConfigFile($basePath)
        {
        }
        protected static function loadConfig($basePath) : \Flarum\Foundation\Config
        {
        }
        protected static function loadExtenders($basePath) : array
        {
        }
    }
    class UninstalledSite implements \Flarum\Foundation\SiteInterface
    {
        /**
         * @var Paths
         */
        protected $paths;
        /**
         * @var string
         */
        private $baseUrl;
        public function __construct(\Flarum\Foundation\Paths $paths, string $baseUrl)
        {
        }
        /**
         * Create and boot a Flarum application instance.
         *
         * @return AppInterface
         */
        public function bootApp() : \Flarum\Foundation\AppInterface
        {
        }
        protected function bootLaravel() : \Illuminate\Contracts\Container\Container
        {
        }
        /**
         * @return ConfigRepository
         */
        protected function getIlluminateConfig()
        {
        }
        protected function registerLogger(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    class ValidationException extends \Exception
    {
        protected $attributes;
        protected $relationships;
        public function __construct(array $attributes, array $relationships = [])
        {
        }
        public function getAttributes()
        {
        }
        public function getRelationships()
        {
        }
    }
}
namespace Flarum\Frontend {
    /**
     * @internal
     */
    class AddLocaleAssets
    {
        /**
         * @var LocaleManager
         */
        protected $locales;
        /**
         * @param LocaleManager $locales
         */
        public function __construct(\Flarum\Locale\LocaleManager $locales)
        {
        }
        public function to(\Flarum\Frontend\Assets $assets)
        {
        }
    }
    /**
     * @internal
     */
    class AddTranslations
    {
        /**
         * @var LocaleManager
         */
        protected $locales;
        /**
         * @var callable
         */
        protected $filter;
        public function __construct(\Flarum\Locale\LocaleManager $locales, callable $filter = null)
        {
        }
        public function forFrontend(string $name)
        {
        }
        public function to(\Flarum\Frontend\Assets $assets)
        {
        }
        private function getTranslations(string $locale)
        {
        }
    }
    /**
     * A factory class for creating frontend asset compilers.
     *
     * @internal
     */
    class Assets
    {
        /**
         * @var array
         */
        public $sources = ['js' => [], 'css' => [], 'localeJs' => [], 'localeCss' => []];
        /**
         * @var string
         */
        protected $name;
        /**
         * @var Filesystem
         */
        protected $assetsDir;
        /**
         * @var string
         */
        protected $cacheDir;
        /**
         * @var array
         */
        protected $lessImportDirs;
        /**
         * @var array
         */
        protected $lessImportOverrides = [];
        /**
         * @var array
         */
        protected $fileSourceOverrides = [];
        public function __construct(string $name, \Illuminate\Contracts\Filesystem\Filesystem $assetsDir, string $cacheDir = null, array $lessImportDirs = null)
        {
        }
        public function js($sources)
        {
        }
        public function css($callback)
        {
        }
        public function localeJs($callback)
        {
        }
        public function localeCss($callback)
        {
        }
        private function addSources($type, $callback)
        {
        }
        private function populate(\Flarum\Frontend\Compiler\CompilerInterface $compiler, string $type, string $locale = null)
        {
        }
        public function makeJs() : \Flarum\Frontend\Compiler\JsCompiler
        {
        }
        public function makeCss() : \Flarum\Frontend\Compiler\LessCompiler
        {
        }
        public function makeLocaleJs(string $locale) : \Flarum\Frontend\Compiler\JsCompiler
        {
        }
        public function makeLocaleCss(string $locale) : \Flarum\Frontend\Compiler\LessCompiler
        {
        }
        protected function makeJsCompiler(string $filename)
        {
        }
        protected function makeLessCompiler(string $filename) : \Flarum\Frontend\Compiler\LessCompiler
        {
        }
        public function getName() : string
        {
        }
        public function setName(string $name)
        {
        }
        public function getAssetsDir() : \Illuminate\Contracts\Filesystem\Filesystem
        {
        }
        public function setAssetsDir(\Illuminate\Contracts\Filesystem\Filesystem $assetsDir)
        {
        }
        public function getCacheDir() : ?string
        {
        }
        public function setCacheDir(?string $cacheDir)
        {
        }
        public function getLessImportDirs() : array
        {
        }
        public function setLessImportDirs(array $lessImportDirs)
        {
        }
        public function addLessImportOverrides(array $lessImportOverrides)
        {
        }
        public function addFileSourceOverrides(array $fileSourceOverrides)
        {
        }
    }
}
namespace Flarum\Frontend\Compiler {
    interface CompilerInterface
    {
        public function getFilename() : string;
        public function setFilename(string $filename);
        public function addSources(callable $callback);
        public function commit(bool $force = false);
        public function getUrl() : ?string;
        public function flush();
    }
    /**
     * @internal
     */
    class RevisionCompiler implements \Flarum\Frontend\Compiler\CompilerInterface
    {
        const REV_MANIFEST = 'rev-manifest.json';
        const EMPTY_REVISION = 'empty';
        /**
         * @var Filesystem
         */
        protected $assetsDir;
        /**
         * @var string
         */
        protected $filename;
        /**
         * @var callable[]
         */
        protected $sourcesCallbacks = [];
        /**
         * @param Filesystem $assetsDir
         * @param string $filename
         */
        public function __construct(\Illuminate\Contracts\Filesystem\Filesystem $assetsDir, string $filename)
        {
        }
        public function getFilename() : string
        {
        }
        public function setFilename(string $filename)
        {
        }
        public function commit(bool $force = false)
        {
        }
        public function addSources(callable $callback)
        {
        }
        /**
         * @return SourceInterface[]
         */
        protected function getSources() : array
        {
        }
        public function getUrl() : ?string
        {
        }
        /**
         * @param string $file
         * @param SourceInterface[] $sources
         * @return bool true if the file was written, false if there was nothing to write
         */
        protected function save(string $file, array $sources) : bool
        {
        }
        /**
         * @param SourceInterface[] $sources
         * @return string
         */
        protected function compile(array $sources) : string
        {
        }
        /**
         * @param string $string
         * @return string
         */
        protected function format(string $string) : string
        {
        }
        protected function getRevision() : ?string
        {
        }
        protected function putRevision(?string $revision)
        {
        }
        /**
         * @param SourceInterface[] $sources
         * @return string
         */
        protected function calculateRevision(array $sources) : string
        {
        }
        protected function getCacheDifferentiator() : ?array
        {
        }
        public function flush()
        {
        }
        /**
         * @param string $file
         */
        protected function delete(string $file)
        {
        }
    }
    /**
     * @internal
     */
    class JsCompiler extends \Flarum\Frontend\Compiler\RevisionCompiler
    {
        protected function save(string $file, array $sources) : bool
        {
        }
        protected function format(string $string) : string
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function delete(string $file)
        {
        }
    }
    /**
     * @internal
     */
    class LessCompiler extends \Flarum\Frontend\Compiler\RevisionCompiler
    {
        /**
         * @var string
         */
        protected $cacheDir;
        /**
         * @var array
         */
        protected $importDirs = [];
        /**
         * @var Collection
         */
        protected $lessImportOverrides;
        /**
         * @var Collection
         */
        protected $fileSourceOverrides;
        public function getCacheDir() : string
        {
        }
        public function setCacheDir(string $cacheDir)
        {
        }
        public function getImportDirs() : array
        {
        }
        public function setImportDirs(array $importDirs)
        {
        }
        public function setLessImportOverrides(array $lessImportOverrides)
        {
        }
        public function setFileSourceOverrides(array $fileSourceOverrides)
        {
        }
        /**
         * @throws \Less_Exception_Parser
         */
        protected function compile(array $sources) : string
        {
        }
        protected function overrideSources(array $sources) : array
        {
        }
        protected function overrideImports(array $sources) : callable
        {
        }
        protected function getCacheDifferentiator() : ?array
        {
        }
    }
}
namespace Flarum\Frontend\Compiler\Source {
    interface SourceInterface
    {
        /**
         * @return string
         */
        public function getContent() : string;
        /**
         * @return mixed
         */
        public function getCacheDifferentiator();
    }
    /**
     * @internal
     */
    class FileSource implements \Flarum\Frontend\Compiler\Source\SourceInterface
    {
        /**
         * @var string
         */
        protected $path;
        /**
         * @var string
         */
        protected $extensionId;
        /**
         * @param string $path
         */
        public function __construct(string $path, ?string $extensionId = null)
        {
        }
        /**
         * @return string
         */
        public function getContent() : string
        {
        }
        /**
         * @return mixed
         */
        public function getCacheDifferentiator()
        {
        }
        /**
         * @return string
         */
        public function getPath() : string
        {
        }
        public function setPath(string $path) : void
        {
        }
        public function getExtensionId() : ?string
        {
        }
    }
    /**
     * @internal
     */
    class SourceCollector
    {
        /**
         * @var SourceInterface[]
         */
        protected $sources = [];
        /**
         * @param string $file
         * @return $this
         */
        public function addFile(string $file, string $extensionId = null)
        {
        }
        /**
         * @param callable $callback
         * @return $this
         */
        public function addString(callable $callback)
        {
        }
        /**
         * @return SourceInterface[]
         */
        public function getSources()
        {
        }
    }
    /**
     * @internal
     */
    class StringSource implements \Flarum\Frontend\Compiler\Source\SourceInterface
    {
        /**
         * @var callable
         */
        protected $callback;
        private $content;
        /**
         * @param callable $callback
         */
        public function __construct(callable $callback)
        {
        }
        /**
         * @return string
         */
        public function getContent() : string
        {
        }
        /**
         * @return mixed
         */
        public function getCacheDifferentiator()
        {
        }
    }
}
namespace Flarum\Frontend\Content {
    class Assets
    {
        protected $container;
        protected $config;
        /**
         * @var \Flarum\Frontend\Assets
         */
        protected $assets;
        public function __construct(\Illuminate\Contracts\Container\Container $container, \Flarum\Foundation\Config $config)
        {
        }
        public function forFrontend(string $name)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * Force compilation of assets when in debug mode.
         *
         * @param array $compilers
         */
        private function forceCommit(array $compilers)
        {
        }
        /**
         * @param CompilerInterface[] $compilers
         * @return string[]
         */
        private function getUrls(array $compilers)
        {
        }
    }
    class CorePayload
    {
        /**
         * @var LocaleManager
         */
        private $locales;
        /**
         * @var Client
         */
        private $api;
        /**
         * @param LocaleManager $locales
         * @param Client $api
         */
        public function __construct(\Flarum\Locale\LocaleManager $locales, \Flarum\Api\Client $api)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        private function buildPayload(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        private function getDataFromApiDocument(array $apiDocument) : array
        {
        }
        private function getUserApiDocument(\Psr\Http\Message\ServerRequestInterface $request, \Flarum\User\User $actor) : array
        {
        }
        private function getResponseBody(\Psr\Http\Message\ResponseInterface $response)
        {
        }
    }
    class Meta
    {
        /**
         * @var LocaleManager
         */
        private $locales;
        /**
         * @param LocaleManager $locales
         */
        public function __construct(\Flarum\Locale\LocaleManager $locales)
        {
        }
        public function __invoke(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        private function buildMeta(\Flarum\Frontend\Document $document)
        {
        }
        private function buildHead(\Flarum\Frontend\Document $document)
        {
        }
    }
}
namespace Flarum\Frontend {
    class Controller implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Frontend
         */
        protected $frontend;
        public function __construct(\Flarum\Frontend\Frontend $frontend)
        {
        }
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * A view which renders a HTML skeleton for Flarum's frontend app.
     */
    class Document implements \Illuminate\Contracts\Support\Renderable
    {
        /**
         * The title of the document, displayed in the <title> tag.
         *
         * @var null|string
         */
        public $title;
        /**
         * The language of the document, displayed as the value of the attribute `lang` in the <html> tag.
         *
         * @var null|string
         */
        public $language;
        /**
         * The text direction of the document, displayed as the value of the attribute `dir` in the <html> tag.
         *
         * @var null|string
         */
        public $direction;
        /**
         * The name of the frontend app view to display.
         *
         * @var string
         */
        public $appView = 'flarum::frontend.app';
        /**
         * The name of the frontend layout view to display.
         *
         * @var string
         */
        public $layoutView;
        /**
         * The name of the frontend content view to display.
         *
         * @var string
         */
        public $contentView = 'flarum::frontend.content';
        /**
         * The SEO content of the page, displayed within the layout in <noscript> tags.
         *
         * @var string|Renderable
         */
        public $content;
        /**
         * Other variables to preload into the Flarum JS.
         *
         * @var array
         */
        public $payload = [];
        /**
         * An array of meta tags to append to the page's <head>.
         *
         * @var array
         */
        public $meta = [];
        /**
         * The canonical URL for this page.
         *
         * This will signal to search engines what URL should be used for this
         * content, if it can be found under multiple addresses. This is an
         * important tool to tackle duplicate content.
         *
         * @var null|string
         */
        public $canonicalUrl;
        /**
         * An array of strings to append to the page's <head>.
         *
         * @var array
         */
        public $head = [];
        /**
         * An array of strings to prepend before the page's </body>.
         *
         * @var array
         */
        public $foot = [];
        /**
         * An array of JavaScript URLs to load.
         *
         * @var array
         */
        public $js = [];
        /**
         * An array of CSS URLs to load.
         *
         * @var array
         */
        public $css = [];
        /**
         * An array of preloaded assets.
         *
         * Each array item should be an array containing keys that pertain to the
         * `<link rel="preload">` tag.
         *
         * For example, the following will add a preload tag for a FontAwesome font file:
         * ```
         * $this->preloads[] = [
         *   'href' => '/assets/fonts/fa-solid-900.woff2',
         *   'as' => 'font',
         *   'type' => 'font/woff2',
         *   'crossorigin' => ''
         * ];
         * ```
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload
         *
         * @var array
         */
        public $preloads = [];
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var array
         */
        protected $forumApiDocument;
        /**
         * @var Request
         */
        protected $request;
        public function __construct(\Illuminate\Contracts\View\Factory $view, array $forumApiDocument, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        /**
         * @return string
         */
        public function render() : string
        {
        }
        /**
         * @return View
         */
        protected function makeView() : \Illuminate\Contracts\View\View
        {
        }
        /**
         * @return string
         */
        protected function makeTitle() : string
        {
        }
        /**
         * @return View
         */
        protected function makeLayout() : \Illuminate\Contracts\View\View
        {
        }
        /**
         * @return View
         */
        protected function makeContent() : \Illuminate\Contracts\View\View
        {
        }
        protected function makePreloads() : array
        {
        }
        /**
         * @return string
         */
        protected function makeHead() : string
        {
        }
        /**
         * @return string
         */
        protected function makeJs() : string
        {
        }
        /**
         * @return string
         */
        protected function makeFoot() : string
        {
        }
        /**
         * @return array
         */
        public function getForumApiDocument() : array
        {
        }
        /**
         * @param array $forumApiDocument
         */
        public function setForumApiDocument(array $forumApiDocument)
        {
        }
    }
}
namespace Flarum\Frontend\Driver {
    interface TitleDriverInterface
    {
        public function makeTitle(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request, array $forumApiDocument) : string;
    }
    class BasicTitleDriver implements \Flarum\Frontend\Driver\TitleDriverInterface
    {
        public function makeTitle(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request, array $forumApiDocument) : string
        {
        }
    }
}
namespace Flarum\Frontend {
    class Frontend
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var Client
         */
        protected $api;
        /**
         * @var callable[]
         */
        protected $content = [];
        public function __construct(\Illuminate\Contracts\View\Factory $view, \Flarum\Api\Client $api)
        {
        }
        /**
         * @param callable $content
         */
        public function content(callable $content)
        {
        }
        public function document(\Psr\Http\Message\ServerRequestInterface $request) : \Flarum\Frontend\Document
        {
        }
        protected function populate(\Flarum\Frontend\Document $document, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
        private function getForumDocument(\Psr\Http\Message\ServerRequestInterface $request) : array
        {
        }
        private function getResponseBody(\Psr\Http\Message\ResponseInterface $response) : array
        {
        }
    }
    class FrontendServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container, \Illuminate\Contracts\View\Factory $views)
        {
        }
        public function addBaseCss(\Flarum\Frontend\Compiler\Source\SourceCollector $sources)
        {
        }
        private function addLessVariables(\Flarum\Frontend\Compiler\Source\SourceCollector $sources)
        {
        }
    }
    /**
     * @internal
     */
    class RecompileFrontendAssets
    {
        /**
         * @var Assets
         */
        protected $assets;
        /**
         * @var LocaleManager
         */
        protected $locales;
        /**
         * @param Assets $assets
         * @param LocaleManager $locales
         */
        public function __construct(\Flarum\Frontend\Assets $assets, \Flarum\Locale\LocaleManager $locales)
        {
        }
        public function whenSettingsSaved(\Flarum\Settings\Event\Saved $event)
        {
        }
        public function flush()
        {
        }
        protected function flushCss()
        {
        }
        protected function flushJs()
        {
        }
    }
}
namespace Flarum\Group\Access {
    class GroupPolicy extends \Flarum\User\Access\AbstractPolicy
    {
        /**
         * @param User $actor
         * @param string $ability
         * @return bool|null
         */
        public function can(\Flarum\User\User $actor, $ability)
        {
        }
    }
    class ScopeGroupVisibility
    {
        /**
         * @param User $actor
         * @param Builder $query
         */
        public function __invoke(\Flarum\User\User $actor, $query)
        {
        }
    }
}
namespace Flarum\Group\Command {
    class CreateGroup
    {
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes of the new group.
         *
         * @var array
         */
        public $data;
        /**
         * @param User $actor The user performing the action.
         * @param array $data The attributes of the new group.
         */
        public function __construct(\Flarum\User\User $actor, array $data)
        {
        }
    }
    class CreateGroupHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\Group\GroupValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param \Flarum\Group\GroupValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Group\GroupValidator $validator)
        {
        }
        /**
         * @param CreateGroup $command
         * @return \Flarum\Group\Group
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Group\Command\CreateGroup $command)
        {
        }
    }
    class DeleteGroup
    {
        /**
         * The ID of the group to delete.
         *
         * @var int
         */
        public $groupId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any other group input associated with the action. This is unused by
         * default, but may be used by extensions.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $groupId The ID of the group to delete.
         * @param User $actor The user performing the action.
         * @param array $data Any other group input associated with the action. This
         *     is unused by default, but may be used by extensions.
         */
        public function __construct($groupId, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
    class DeleteGroupHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var GroupRepository
         */
        protected $groups;
        /**
         * @param GroupRepository $groups
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Group\GroupRepository $groups)
        {
        }
        /**
         * @param DeleteGroup $command
         * @return \Flarum\Group\Group
         * @throws PermissionDeniedException
         */
        public function handle(\Flarum\Group\Command\DeleteGroup $command)
        {
        }
    }
    class EditGroup
    {
        /**
         * The ID of the group to edit.
         *
         * @var int
         */
        public $groupId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the post.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $groupId The ID of the group to edit.
         * @param User $actor The user performing the action.
         * @param array $data The attributes to update on the post.
         */
        public function __construct($groupId, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class EditGroupHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\Group\GroupRepository
         */
        protected $groups;
        /**
         * @var GroupValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param GroupRepository $groups
         * @param GroupValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Group\GroupRepository $groups, \Flarum\Group\GroupValidator $validator)
        {
        }
        /**
         * @param EditGroup $command
         * @return Group
         * @throws PermissionDeniedException
         */
        public function handle(\Flarum\Group\Command\EditGroup $command)
        {
        }
    }
}
namespace Flarum\Group\Event {
    class Created
    {
        /**
         * @var \Flarum\Group\Group
         */
        public $group;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param Group $group
         * @param User $actor
         */
        public function __construct(\Flarum\Group\Group $group, \Flarum\User\User $actor = null)
        {
        }
    }
    class Deleted
    {
        /**
         * @var \Flarum\Group\Group
         */
        public $group;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Group\Group $group
         * @param User $actor
         */
        public function __construct(\Flarum\Group\Group $group, \Flarum\User\User $actor = null)
        {
        }
    }
    class Deleting
    {
        /**
         * The group that will be deleted.
         *
         * @var Group
         */
        public $group;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any user input associated with the command.
         *
         * @var array
         */
        public $data;
        /**
         * @param Group $group The group that will be deleted.
         * @param User $actor The user performing the action.
         * @param array $data Any user input associated with the command.
         */
        public function __construct(\Flarum\Group\Group $group, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class Renamed
    {
        /**
         * @var \Flarum\Group\Group
         */
        public $group;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Group\Group $group
         * @param User $actor
         */
        public function __construct(\Flarum\Group\Group $group, \Flarum\User\User $actor = null)
        {
        }
    }
    class Saving
    {
        /**
         * The group that will be saved.
         *
         * @var \Flarum\Group\Group
         */
        public $group;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the group.
         *
         * @var array
         */
        public $data;
        /**
         * @param Group $group The group that will be saved.
         * @param User $actor The user who is performing the action.
         * @param array $data The attributes to update on the group.
         */
        public function __construct(\Flarum\Group\Group $group, \Flarum\User\User $actor, array $data)
        {
        }
    }
}
namespace Flarum\Group\Filter {
    class GroupFilterer extends \Flarum\Filter\AbstractFilterer
    {
        /**
         * @var GroupRepository
         */
        protected $groups;
        /**
         * @param GroupRepository $groups
         * @param array $filters
         * @param array $filterMutators
         */
        public function __construct(\Flarum\Group\GroupRepository $groups, array $filters, array $filterMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
    class HiddenFilter implements \Flarum\Filter\FilterInterface
    {
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
}
namespace Flarum\Group {
    /**
     * @property int $id
     * @property string $name_singular
     * @property string $name_plural
     * @property string|null $color
     * @property string|null $icon
     * @property bool $is_hidden
     * @property \Illuminate\Database\Eloquent\Collection $users
     * @property \Illuminate\Database\Eloquent\Collection $permissions
     */
    class Group extends \Flarum\Database\AbstractModel
    {
        use \Flarum\Foundation\EventGeneratorTrait;
        use \Flarum\Database\ScopeVisibilityTrait;
        /**
         * The ID of the administrator group.
         */
        const ADMINISTRATOR_ID = 1;
        /**
         * The ID of the guest group.
         */
        const GUEST_ID = 2;
        /**
         * The ID of the member group.
         */
        const MEMBER_ID = 3;
        /**
         * The ID of the mod group.
         */
        const MODERATOR_ID = 4;
        /**
         * Boot the model.
         *
         * @return void
         */
        public static function boot()
        {
        }
        /**
         * Create a new group.
         *
         * @param string $nameSingular
         * @param string $namePlural
         * @param string $color
         * @param string $icon
         * @param bool   $isHidden
         * @return static
         */
        public static function build($nameSingular, $namePlural, $color = null, $icon = null, bool $isHidden = false) : self
        {
        }
        /**
         * Rename the group.
         *
         * @param string $nameSingular
         * @param string $namePlural
         * @return $this
         */
        public function rename($nameSingular, $namePlural)
        {
        }
        /**
         * Define the relationship with the group's users.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
         */
        public function users()
        {
        }
        /**
         * Define the relationship with the group's permissions.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function permissions()
        {
        }
        /**
         * Check whether the group has a certain permission.
         *
         * @param string $permission
         * @return bool
         */
        public function hasPermission($permission)
        {
        }
    }
    class GroupRepository
    {
        /**
         * Get a new query builder for the groups table.
         *
         * @return Builder
         */
        public function query()
        {
        }
        /**
         * Find a user by ID, optionally making sure it is visible to a certain
         * user, or throw an exception.
         *
         * @param int $id
         * @param User $actor
         * @return \Flarum\Group\Group
         *
         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
         */
        public function findOrFail($id, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Scope a query to only include records that are visible to a user.
         *
         * @param Builder $query
         * @param User $actor
         * @return Builder
         */
        protected function scopeVisibleTo(\Illuminate\Database\Eloquent\Builder $query, \Flarum\User\User $actor = null)
        {
        }
    }
    class GroupServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function boot()
        {
        }
    }
    class GroupValidator extends \Flarum\Foundation\AbstractValidator
    {
        protected $rules = ['name_singular' => ['required'], 'name_plural' => ['required']];
    }
    /**
     * @property int $group_id
     * @property string $permission
     */
    class Permission extends \Flarum\Database\AbstractModel
    {
        /**
         * {@inheritdoc}
         */
        protected $table = 'group_permission';
        /**
         * Define the relationship with the group that this permission is for.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function group()
        {
        }
        /**
         * Set the keys for a save update query.
         *
         * @param Builder $query
         * @return Builder
         */
        protected function setKeysForSaveQuery($query)
        {
        }
        /**
         * Get a map of permissions to the group IDs that have them.
         *
         * @return array[]
         */
        public static function map()
        {
        }
    }
}
namespace Flarum\Http {
    /**
     * @property int $id
     * @property string $token
     * @property int $user_id
     * @property Carbon $created_at
     * @property Carbon|null $last_activity_at
     * @property string $type
     * @property string $title
     * @property string $last_ip_address
     * @property string $last_user_agent
     * @property \Flarum\User\User|null $user
     */
    class AccessToken extends \Flarum\Database\AbstractModel
    {
        protected $table = 'access_tokens';
        protected $dates = ['created_at', 'last_activity_at'];
        /**
         * A map of access token types, as specified in the `type` column, to their classes.
         *
         * @var array
         */
        protected static $models = [];
        /**
         * The type of token this is, to be stored in the access tokens table.
         *
         * Should be overwritten by subclasses with the value that is
         * to be stored in the database, which will then be used for
         * mapping the hydrated model instance to the proper subtype.
         *
         * @var string
         */
        public static $type = '';
        /**
         * How long this access token should be valid from the time of last activity.
         * This value will be used in the validity and expiration checks.
         * @var int Lifetime in seconds. Zero means it will never expire.
         */
        protected static $lifetime = 0;
        /**
         * Generate an access token for the specified user.
         *
         * @param int $userId
         * @return static
         */
        public static function generate($userId)
        {
        }
        /**
         * Update the time of last usage of a token.
         * If a request object is provided, the IP address and User Agent will also be logged.
         * @param ServerRequestInterface|null $request
         * @return bool
         */
        public function touch(\Psr\Http\Message\ServerRequestInterface $request = null)
        {
        }
        /**
         * Define the relationship with the owner of this access token.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Filters which tokens are valid at the given date for this particular token type.
         * Uses the static::$lifetime value by default, can be overridden by children classes.
         * @param Builder $query
         * @param Carbon $date
         */
        protected static function scopeValid(\Illuminate\Database\Eloquent\Builder $query, \Carbon\Carbon $date)
        {
        }
        /**
         * Filters which tokens are expired at the given date and ready for garbage collection.
         * Uses the static::$lifetime value by default, can be overridden by children classes.
         * @param Builder $query
         * @param Carbon $date
         */
        protected static function scopeExpired(\Illuminate\Database\Eloquent\Builder $query, \Carbon\Carbon $date)
        {
        }
        /**
         * Shortcut to find a valid token.
         * @param string $token Token as sent by the user. We allow non-string values like null so we can directly feed any value from a request.
         * @return AccessToken|null
         */
        public static function findValid($token) : ?\Flarum\Http\AccessToken
        {
        }
        /**
         * This query scope is intended to be used on the base AccessToken object to query for valid tokens of any type.
         * @param Builder $query
         * @param Carbon|null $date
         */
        public function scopeWhereValid(\Illuminate\Database\Eloquent\Builder $query, \Carbon\Carbon $date = null)
        {
        }
        /**
         * This query scope is intended to be used on the base AccessToken object to query for expired tokens of any type.
         * @param Builder $query
         * @param Carbon|null $date
         */
        public function scopeWhereExpired(\Illuminate\Database\Eloquent\Builder $query, \Carbon\Carbon $date = null)
        {
        }
        /**
         * Create a new model instance according to the access token type.
         *
         * @param array $attributes
         * @param string|null $connection
         * @return static|object
         */
        public function newFromBuilder($attributes = [], $connection = null)
        {
        }
        /**
         * Get the type-to-model map.
         *
         * @return array
         */
        public static function getModels()
        {
        }
        /**
         * Set the model for the given access token type.
         *
         * @param string $type The access token type.
         * @param string $model The class name of the model for that type.
         * @return void
         */
        public static function setModel(string $type, string $model)
        {
        }
    }
    class ActorReference
    {
        /**
         * @var User
         */
        private $actor;
        public function setActor(\Flarum\User\User $actor)
        {
        }
        public function getActor() : \Flarum\User\User
        {
        }
    }
    class CookieFactory
    {
        /**
         * The prefix for the cookie names.
         *
         * @var string
         */
        protected $prefix;
        /**
         * A path scope for the cookies.
         *
         * @var string
         */
        protected $path;
        /**
         * A domain scope for the cookies.
         *
         * @var string
         */
        protected $domain;
        /**
         * Whether the cookie(s) can be requested only over HTTPS.
         *
         * @var bool
         */
        protected $secure;
        /**
         * Same Site cookie value.
         *
         * @var string
         */
        protected $samesite;
        /**
         * @param Config $config
         */
        public function __construct(\Flarum\Foundation\Config $config)
        {
        }
        /**
         * Make a new cookie instance.
         *
         * This method returns a cookie instance for use with the Set-Cookie HTTP header.
         * It will be pre-configured according to Flarum's base URL and protocol.
         *
         * @param  string  $name
         * @param  string  $value
         * @param  int     $maxAge
         * @return \Dflydev\FigCookies\SetCookie
         */
        public function make(string $name, string $value = null, int $maxAge = null) : \Dflydev\FigCookies\SetCookie
        {
        }
        /**
         * Make an expired cookie instance.
         *
         * @param string $name
         * @return \Dflydev\FigCookies\SetCookie
         */
        public function expire(string $name) : \Dflydev\FigCookies\SetCookie
        {
        }
        /**
         * Get a cookie name.
         *
         * @param string $name
         * @return string
         */
        public function getName(string $name) : string
        {
        }
    }
    class DeveloperAccessToken extends \Flarum\Http\AccessToken
    {
        public static $type = 'developer';
        protected static $lifetime = 0;
    }
}
namespace Flarum\Http\Exception {
    class MethodNotAllowedException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
    class RouteNotFoundException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
    class TokenMismatchException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
}
namespace Flarum\Http {
    class HttpServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot()
        {
        }
        protected function setAccessTokenTypes()
        {
        }
    }
}
namespace Flarum\Http\Middleware {
    class AuthenticateWithHeader implements \Psr\Http\Server\MiddlewareInterface
    {
        const TOKEN_PREFIX = 'Token ';
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function getUser($string)
        {
        }
    }
    class AuthenticateWithSession implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function getActor(\Illuminate\Contracts\Session\Session $session, \Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class CheckCsrfToken implements \Psr\Http\Server\MiddlewareInterface
    {
        protected $exemptRoutes;
        public function __construct(array $exemptRoutes)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function tokensMatch(\Psr\Http\Message\ServerRequestInterface $request) : bool
        {
        }
    }
    class CollectGarbage implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var SessionHandlerInterface
         */
        protected $sessionHandler;
        /**
         * @var array
         */
        protected $sessionConfig;
        public function __construct(\SessionHandlerInterface $handler, \Illuminate\Contracts\Config\Repository $config)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function collectGarbageSometimes()
        {
        }
        private function hit()
        {
        }
        private function getSessionLifetimeInSeconds()
        {
        }
    }
    class ContentTypeOptionsHeader implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ExecuteRoute implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * Executes the route handler resolved in ResolveRoute.
         */
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class FlarumPromotionHeader implements \Psr\Http\Server\MiddlewareInterface
    {
        protected $enabled = true;
        public function __construct(\Flarum\Foundation\Config $config)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Catch exceptions thrown in a PSR-15 middleware stack and handle them safely.
     *
     * All errors will be rendered using the provided formatter. In addition,
     * unknown errors will be passed on to one or multiple
     * {@see \Flarum\Foundation\ErrorHandling\Reporter} instances.
     */
    class HandleErrors implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var Registry
         */
        protected $registry;
        /**
         * @var HttpFormatter
         */
        protected $formatter;
        /**
         * @var \Flarum\Foundation\ErrorHandling\Reporter[]
         */
        protected $reporters;
        public function __construct(\Flarum\Foundation\ErrorHandling\Registry $registry, \Flarum\Foundation\ErrorHandling\HttpFormatter $formatter, iterable $reporters)
        {
        }
        /**
         * Catch all errors that happen during further middleware execution.
         */
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class InjectActorReference implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ParseJsonBody implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ProcessIp implements \Psr\Http\Server\MiddlewareInterface
    {
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ReferrerPolicyHeader implements \Psr\Http\Server\MiddlewareInterface
    {
        protected $policy = '';
        public function __construct(\Flarum\Foundation\Config $config)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class RememberFromCookie implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var CookieFactory
         */
        protected $cookie;
        /**
         * @param CookieFactory $cookie
         */
        public function __construct(\Flarum\Http\CookieFactory $cookie)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class ResolveRoute implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var RouteCollection
         */
        protected $routes;
        /**
         * @var Dispatcher
         */
        protected $dispatcher;
        /**
         * Create the middleware instance.
         *
         * @param RouteCollection $routes
         */
        public function __construct(\Flarum\Http\RouteCollection $routes)
        {
        }
        /**
         * Resolve the given request from our route collection.
         *
         * @throws MethodNotAllowedException
         * @throws RouteNotFoundException
         */
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        protected function getDispatcher()
        {
        }
    }
    class SetLocale implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var LocaleManager
         */
        protected $locales;
        /**
         * @param LocaleManager $locales
         */
        public function __construct(\Flarum\Locale\LocaleManager $locales)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    /**
     * Inspired by Illuminate\View\Middleware\ShareErrorsFromSession.
     *
     * @author Taylor Otwell
     */
    class ShareErrorsFromSession implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var ViewFactory
         */
        protected $view;
        /**
         * @param ViewFactory $view
         */
        public function __construct(\Illuminate\Contracts\View\Factory $view)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
    class StartSession implements \Psr\Http\Server\MiddlewareInterface
    {
        /**
         * @var SessionHandlerInterface
         */
        protected $handler;
        /**
         * @var CookieFactory
         */
        protected $cookie;
        /**
         * @var array
         */
        protected $config;
        /**
         * @param SessionHandlerInterface $handler
         * @param CookieFactory $cookie
         * @param ConfigRepository $config
         */
        public function __construct(\SessionHandlerInterface $handler, \Flarum\Http\CookieFactory $cookie, \Illuminate\Contracts\Config\Repository $config)
        {
        }
        public function process(\Psr\Http\Message\ServerRequestInterface $request, \Psr\Http\Server\RequestHandlerInterface $handler) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function makeSession(\Psr\Http\Message\ServerRequestInterface $request) : \Illuminate\Contracts\Session\Session
        {
        }
        private function withCsrfTokenHeader(\Psr\Http\Message\ResponseInterface $response, \Illuminate\Contracts\Session\Session $session) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function withSessionCookie(\Psr\Http\Message\ResponseInterface $response, \Illuminate\Contracts\Session\Session $session) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function getSessionLifetimeInSeconds() : int
        {
        }
    }
}
namespace Flarum\Http {
    class RememberAccessToken extends \Flarum\Http\AccessToken
    {
        public static $type = 'session_remember';
        protected static $lifetime = 5 * 365 * 24 * 60 * 60;
        // 5 years
        /**
         * Just a helper method so we can re-use the lifetime value which is protected.
         * @return int
         */
        public static function rememberCookieLifeTime() : int
        {
        }
    }
    class Rememberer
    {
        const COOKIE_NAME = 'remember';
        /**
         * @var CookieFactory
         */
        protected $cookie;
        /**
         * @param CookieFactory $cookie
         */
        public function __construct(\Flarum\Http\CookieFactory $cookie)
        {
        }
        /**
         * Sets the remember cookie on a response.
         * @param ResponseInterface $response
         * @param RememberAccessToken $token The remember token to set on the response.
         * @return ResponseInterface
         */
        public function remember(\Psr\Http\Message\ResponseInterface $response, \Flarum\Http\RememberAccessToken $token)
        {
        }
        public function forget(\Psr\Http\Message\ResponseInterface $response)
        {
        }
    }
    class RequestUtil
    {
        public static function getActor(\Psr\Http\Message\ServerRequestInterface $request) : \Flarum\User\User
        {
        }
        public static function withActor(\Psr\Http\Message\ServerRequestInterface $request, \Flarum\User\User $actor) : \Psr\Http\Message\ServerRequestInterface
        {
        }
    }
    /**
     * @internal
     */
    class RouteCollection
    {
        /**
         * @var array
         */
        protected $reverse = [];
        /**
         * @var DataGenerator
         */
        protected $dataGenerator;
        /**
         * @var RouteParser
         */
        protected $routeParser;
        /**
         * @var array
         */
        protected $routes = [];
        /**
         * @var array
         */
        protected $pendingRoutes = [];
        public function __construct()
        {
        }
        public function get($path, $name, $handler)
        {
        }
        public function post($path, $name, $handler)
        {
        }
        public function put($path, $name, $handler)
        {
        }
        public function patch($path, $name, $handler)
        {
        }
        public function delete($path, $name, $handler)
        {
        }
        public function addRoute($method, $path, $name, $handler)
        {
        }
        public function removeRoute(string $name) : self
        {
        }
        protected function applyRoutes() : void
        {
        }
        public function getRoutes() : array
        {
        }
        public function getRouteData()
        {
        }
        protected function fixPathPart($part, array $parameters, string $routeName)
        {
        }
        public function getPath($name, array $parameters = [])
        {
        }
    }
    /**
     * @internal
     */
    class RouteCollectionUrlGenerator
    {
        /**
         * @var string|null
         */
        protected $baseUrl;
        /**
         * @var RouteCollection
         */
        protected $routes;
        /**
         * @param string $baseUrl
         * @param RouteCollection $routes
         */
        public function __construct($baseUrl, \Flarum\Http\RouteCollection $routes)
        {
        }
        /**
         * Generate a URL to a named route.
         *
         * @param string $name
         * @param array $parameters
         * @return string
         */
        public function route($name, $parameters = [])
        {
        }
        /**
         * Generate a URL to a path.
         *
         * @param string $path
         * @return string
         */
        public function path($path)
        {
        }
        /**
         * Generate a URL to base with UrlGenerator's prefix.
         *
         * @return string
         */
        public function base()
        {
        }
    }
    /**
     * @internal
     */
    class RouteHandlerFactory
    {
        /**
         * @var Container
         */
        protected $container;
        public function __construct(\Illuminate\Contracts\Container\Container $container)
        {
        }
        public function toController($controller) : \Closure
        {
        }
        /**
         * @param string $frontend
         * @param string|callable|null $content
         */
        public function toFrontend(string $frontend, $content = null) : \Closure
        {
        }
        public function toForum(string $content = null) : \Closure
        {
        }
        public function toAdmin(string $content = null) : \Closure
        {
        }
        private function resolveController($controller) : \Psr\Http\Server\RequestHandlerInterface
        {
        }
    }
    class Server
    {
        private $site;
        public function __construct(\Flarum\Foundation\SiteInterface $site)
        {
        }
        public function listen()
        {
        }
        /**
         * Try to boot Flarum, and retrieve the app's HTTP request handler.
         *
         * We catch all exceptions happening during this process and format them to
         * prevent exposure of sensitive information.
         *
         * @return \Psr\Http\Server\RequestHandlerInterface
         */
        private function safelyBootAndGetHandler()
        {
        }
        /**
         * Attempt to log the boot exception in a clean way and stop the script execution.
         * This means looking for debug mode and/or our normal error logger.
         * There is always a risk for this to fail,
         * for example if the container bindings aren't present
         * or if there is a filesystem error.
         * @param Throwable $error
         */
        private function cleanBootExceptionLog(\Throwable $error)
        {
        }
        /**
         * If the clean logging doesn't work, then we have a last opportunity.
         * Here we need to be extra careful not to include anything that might be sensitive on the page.
         * @param Throwable $error
         * @throws Throwable
         */
        private function fallbackBootExceptionLog(\Throwable $error)
        {
        }
    }
    class SessionAccessToken extends \Flarum\Http\AccessToken
    {
        public static $type = 'session';
        protected static $lifetime = 60 * 60;
        // 1 hour
    }
    class SessionAuthenticator
    {
        /**
         * @param Session $session
         * @param AccessToken $token
         */
        public function logIn(\Illuminate\Contracts\Session\Session $session, \Flarum\Http\AccessToken $token)
        {
        }
        /**
         * @param Session $session
         */
        public function logOut(\Illuminate\Contracts\Session\Session $session)
        {
        }
    }
    class SlugManager
    {
        protected $drivers = [];
        public function __construct(array $drivers)
        {
        }
        public function forResource(string $resourceName) : \Flarum\Http\SlugDriverInterface
        {
        }
    }
    class UrlGenerator
    {
        /**
         * @var array
         */
        protected $routes = [];
        /**
         * @var Application
         */
        protected $app;
        /**
         * @param Application $app
         */
        public function __construct(\Flarum\Foundation\Application $app)
        {
        }
        /**
         * Register a named route collection for URL generation.
         *
         * @param string $key
         * @param RouteCollection $routes
         * @param string $prefix
         * @return static
         */
        public function addCollection($key, \Flarum\Http\RouteCollection $routes, $prefix = null)
        {
        }
        /**
         * Retrieve an URL generator instance for the given named route collection.
         *
         * @param string $collection
         * @return RouteCollectionUrlGenerator
         */
        public function to($collection)
        {
        }
    }
}
namespace Flarum\Install {
    class AdminUser
    {
        private $username;
        private $password;
        private $email;
        public function __construct($username, $password, $email)
        {
        }
        public function getUsername()
        {
        }
        public function getAttributes() : array
        {
        }
        private function validate()
        {
        }
    }
    final class BaseUrl
    {
        /** @var string */
        private $normalized;
        private function __construct(string $baseUrl)
        {
        }
        public static function fromString(string $baseUrl) : self
        {
        }
        public static function fromUri(\Psr\Http\Message\UriInterface $baseUrl) : self
        {
        }
        public function __toString() : string
        {
        }
        /**
         * Generate a valid e-mail address for this base URL's domain.
         *
         * This uses the given mailbox name and our already normalized host name to
         * construct an email address.
         *
         * @param string $mailbox
         * @return string
         */
        public function toEmail(string $mailbox) : string
        {
        }
        private function normalize(string $baseUrl) : string
        {
        }
    }
}
namespace Flarum\Install\Console {
    interface DataProviderInterface
    {
        public function configure(\Flarum\Install\Installation $installation) : \Flarum\Install\Installation;
    }
    class FileDataProvider implements \Flarum\Install\Console\DataProviderInterface
    {
        protected $debug = false;
        protected $baseUrl = null;
        protected $databaseConfiguration = [];
        protected $adminUser = [];
        protected $settings = [];
        public function __construct(\Symfony\Component\Console\Input\InputInterface $input)
        {
        }
        public function configure(\Flarum\Install\Installation $installation) : \Flarum\Install\Installation
        {
        }
        private function getDatabaseConfiguration() : \Flarum\Install\DatabaseConfig
        {
        }
        private function getAdminUser() : \Flarum\Install\AdminUser
        {
        }
    }
    class InstallCommand extends \Flarum\Console\AbstractCommand
    {
        /**
         * @var Installation
         */
        protected $installation;
        /**
         * @var DataProviderInterface
         */
        protected $dataSource;
        /**
         * @param Installation $installation
         */
        public function __construct(\Flarum\Install\Installation $installation)
        {
        }
        protected function configure()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function fire()
        {
        }
        protected function init()
        {
        }
        protected function install()
        {
        }
        private function runPipeline(\Flarum\Install\Pipeline $pipeline)
        {
        }
        protected function showProblems($problems)
        {
        }
    }
    class UserDataProvider implements \Flarum\Install\Console\DataProviderInterface
    {
        protected $input;
        protected $output;
        protected $questionHelper;
        /** @var BaseUrl */
        protected $baseUrl;
        public function __construct(\Symfony\Component\Console\Input\InputInterface $input, \Symfony\Component\Console\Output\OutputInterface $output, \Symfony\Component\Console\Helper\QuestionHelper $questionHelper)
        {
        }
        public function configure(\Flarum\Install\Installation $installation) : \Flarum\Install\Installation
        {
        }
        private function getDatabaseConfiguration() : \Flarum\Install\DatabaseConfig
        {
        }
        private function getBaseUrl() : \Flarum\Install\BaseUrl
        {
        }
        private function getAdminUser() : \Flarum\Install\AdminUser
        {
        }
        private function askForAdminPassword()
        {
        }
        private function getSettings()
        {
        }
        private function ask($question, $default = null)
        {
        }
        private function secret($question)
        {
        }
        private function validationError($message)
        {
        }
    }
}
namespace Flarum\Install\Controller {
    class IndexController extends \Flarum\Http\Controller\AbstractHtmlController
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @var Installation
         */
        protected $installation;
        /**
         * @param Factory $view
         * @param Installation $installation
         */
        public function __construct(\Illuminate\Contracts\View\Factory $view, \Flarum\Install\Installation $installation)
        {
        }
        /**
         * @param Request $request
         * @return \Illuminate\Contracts\Support\Renderable
         */
        public function render(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class InstallController implements \Psr\Http\Server\RequestHandlerInterface
    {
        /**
         * @var Installation
         */
        protected $installation;
        /**
         * @var SessionAuthenticator
         */
        protected $authenticator;
        /**
         * @var Rememberer
         */
        protected $rememberer;
        /**
         * InstallController constructor.
         * @param Installation $installation
         * @param SessionAuthenticator $authenticator
         * @param Rememberer $rememberer
         */
        public function __construct(\Flarum\Install\Installation $installation, \Flarum\Http\SessionAuthenticator $authenticator, \Flarum\Http\Rememberer $rememberer)
        {
        }
        /**
         * @param Request $request
         * @return ResponseInterface
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
        private function makeDatabaseConfig(array $input) : \Flarum\Install\DatabaseConfig
        {
        }
        /**
         * @param array $input
         * @return AdminUser
         * @throws ValidationFailed
         */
        private function makeAdminUser(array $input) : \Flarum\Install\AdminUser
        {
        }
        private function getConfirmedAdminPassword(array $input) : string
        {
        }
    }
}
namespace Flarum\Install {
    class DatabaseConfig implements \Illuminate\Contracts\Support\Arrayable
    {
        private $driver;
        private $host;
        private $port;
        private $database;
        private $username;
        private $password;
        private $prefix;
        public function __construct($driver, $host, $port, $database, $username, $password, $prefix)
        {
        }
        public function toArray()
        {
        }
        private function validate()
        {
        }
    }
    class Installation
    {
        /**
         * @var Paths
         */
        private $paths;
        private $configPath;
        private $debug = false;
        private $baseUrl;
        private $customSettings = [];
        private $enabledExtensions = null;
        /** @var DatabaseConfig */
        private $dbConfig;
        /** @var AdminUser */
        private $adminUser;
        private $accessToken;
        // A few instance variables to persist objects between steps.
        // Could also be local variables in build(), but this way
        // access in closures is easier. :)
        /** @var \Illuminate\Database\ConnectionInterface */
        private $db;
        public function __construct(\Flarum\Foundation\Paths $paths)
        {
        }
        public function configPath($path)
        {
        }
        public function debugMode($flag)
        {
        }
        public function databaseConfig(\Flarum\Install\DatabaseConfig $dbConfig)
        {
        }
        public function baseUrl(\Flarum\Install\BaseUrl $baseUrl)
        {
        }
        public function settings($settings)
        {
        }
        public function extensions($enabledExtensions)
        {
        }
        public function adminUser(\Flarum\Install\AdminUser $admin)
        {
        }
        public function accessToken(string $token)
        {
        }
        public function prerequisites() : \Flarum\Install\Prerequisite\PrerequisiteInterface
        {
        }
        public function build() : \Flarum\Install\Pipeline
        {
        }
        private function getConfigPath()
        {
        }
        private function getAssetPath()
        {
        }
        private function getMigrationPath()
        {
        }
    }
    class Installer implements \Flarum\Foundation\AppInterface
    {
        /**
         * @var Container
         */
        protected $container;
        public function __construct(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * @return \Psr\Http\Server\RequestHandlerInterface
         */
        public function getRequestHandler()
        {
        }
        /**
         * @return \Symfony\Component\Console\Command\Command[]
         */
        public function getConsoleCommands()
        {
        }
    }
    class InstallServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container, \Flarum\Http\RouteHandlerFactory $route)
        {
        }
        /**
         * @param RouteCollection     $routes
         * @param RouteHandlerFactory $route
         */
        protected function populateRoutes(\Flarum\Http\RouteCollection $routes, \Flarum\Http\RouteHandlerFactory $route)
        {
        }
    }
    class Pipeline
    {
        /**
         * @var callable[]
         */
        private $steps;
        /**
         * @var callable[]
         */
        private $callbacks;
        /**
         * @var SplStack
         */
        private $successfulSteps;
        public function __construct(array $steps = [])
        {
        }
        public function pipe(callable $factory)
        {
        }
        public function on($event, callable $callback)
        {
        }
        public function run()
        {
        }
        /**
         * @param callable $factory
         * @throws StepFailed
         */
        private function runStep(callable $factory)
        {
        }
        private function revertReversibleSteps()
        {
        }
        private function fireCallbacks($event, \Flarum\Install\Step $step)
        {
        }
    }
}
namespace Flarum\Install\Prerequisite {
    interface PrerequisiteInterface
    {
        /**
         * Verify that this prerequisite is fulfilled.
         *
         * If everything is okay, this method should return an empty Collection
         * instance. When problems are detected, it should return a Collection of
         * arrays, each having at least a "message" and optionally a "detail" key.
         *
         * @return Collection
         */
        public function problems() : \Illuminate\Support\Collection;
    }
    class Composite implements \Flarum\Install\Prerequisite\PrerequisiteInterface
    {
        /**
         * @var PrerequisiteInterface[]
         */
        protected $prerequisites = [];
        public function __construct(\Flarum\Install\Prerequisite\PrerequisiteInterface $first)
        {
        }
        public function problems() : \Illuminate\Support\Collection
        {
        }
    }
    class PhpExtensions implements \Flarum\Install\Prerequisite\PrerequisiteInterface
    {
        protected $extensions;
        public function __construct(array $extensions)
        {
        }
        public function problems() : \Illuminate\Support\Collection
        {
        }
    }
    class PhpVersion implements \Flarum\Install\Prerequisite\PrerequisiteInterface
    {
        protected $minVersion;
        public function __construct($minVersion)
        {
        }
        public function problems() : \Illuminate\Support\Collection
        {
        }
    }
    class WritablePaths implements \Flarum\Install\Prerequisite\PrerequisiteInterface
    {
        /**
         * @var Collection
         */
        private $paths;
        private $wildcards = [];
        public function __construct(array $paths)
        {
        }
        public function problems() : \Illuminate\Support\Collection
        {
        }
        private function getMissingPaths() : \Illuminate\Support\Collection
        {
        }
        private function getNonWritablePaths() : \Illuminate\Support\Collection
        {
        }
        private function getAbsolutePath($path)
        {
        }
        private function normalize(array $paths) : \Illuminate\Support\Collection
        {
        }
    }
}
namespace Flarum\Install {
    interface ReversibleStep
    {
        public function revert();
    }
    interface Step
    {
        /**
         * A one-line status message summarizing what's happening in this step.
         *
         * @return string
         */
        public function getMessage();
        /**
         * Do the work that constitutes this step.
         *
         * This method should raise a `StepFailed` exception whenever something goes
         * wrong that should result in the entire installation being reverted.
         *
         * @return void
         * @throws StepFailed
         */
        public function run();
    }
    class StepFailed extends \Exception
    {
    }
}
namespace Flarum\Install\Steps {
    class ConnectToDatabase implements \Flarum\Install\Step
    {
        private $dbConfig;
        private $store;
        public function __construct(\Flarum\Install\DatabaseConfig $dbConfig, callable $store)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
    }
    class CreateAdminUser implements \Flarum\Install\Step
    {
        /**
         * @var ConnectionInterface
         */
        private $database;
        /**
         * @var AdminUser
         */
        private $admin;
        /**
         * @var string|null
         */
        private $accessToken;
        public function __construct(\Illuminate\Database\ConnectionInterface $database, \Flarum\Install\AdminUser $admin, string $accessToken = null)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
    }
    class EnableBundledExtensions implements \Flarum\Install\Step
    {
        const EXTENSION_WHITELIST = ['flarum-approval', 'flarum-bbcode', 'flarum-emoji', 'flarum-lang-english', 'flarum-flags', 'flarum-likes', 'flarum-lock', 'flarum-markdown', 'flarum-mentions', 'flarum-statistics', 'flarum-sticky', 'flarum-subscriptions', 'flarum-suspend', 'flarum-tags'];
        /**
         * @var ConnectionInterface
         */
        private $database;
        /**
         * @var string
         */
        private $vendorPath;
        /**
         * @var string
         */
        private $assetPath;
        /**
         * @var string[]|null
         */
        private $enabledExtensions;
        public function __construct(\Illuminate\Database\ConnectionInterface $database, $vendorPath, $assetPath, $enabledExtensions = null)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
        /**
         * @return \Illuminate\Support\Collection
         */
        private function loadExtensions()
        {
        }
        private function getMigrator()
        {
        }
    }
    class PublishAssets implements \Flarum\Install\Step, \Flarum\Install\ReversibleStep
    {
        /**
         * @var string
         */
        private $vendorPath;
        /**
         * @var string
         */
        private $assetPath;
        public function __construct($vendorPath, $assetPath)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
        public function revert()
        {
        }
        private function targetPath()
        {
        }
    }
    class RunMigrations implements \Flarum\Install\Step
    {
        /**
         * @var ConnectionInterface
         */
        private $database;
        /**
         * @var string
         */
        private $path;
        public function __construct(\Illuminate\Database\ConnectionInterface $database, $path)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
        private function getMigrator()
        {
        }
    }
    class StoreConfig implements \Flarum\Install\Step, \Flarum\Install\ReversibleStep
    {
        private $debugMode;
        private $dbConfig;
        private $baseUrl;
        private $configFile;
        public function __construct($debugMode, \Flarum\Install\DatabaseConfig $dbConfig, \Flarum\Install\BaseUrl $baseUrl, $configFile)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
        public function revert()
        {
        }
        private function buildConfig()
        {
        }
        private function getPathsConfig()
        {
        }
    }
    class WriteSettings implements \Flarum\Install\Step
    {
        /**
         * @var ConnectionInterface
         */
        private $database;
        /**
         * @var array
         */
        private $custom;
        public function __construct(\Illuminate\Database\ConnectionInterface $database, array $custom)
        {
        }
        public function getMessage()
        {
        }
        public function run()
        {
        }
        private function getSettings()
        {
        }
        private function getDefaults()
        {
        }
    }
}
namespace Flarum\Install {
    class ValidationFailed extends \Exception
    {
    }
}
namespace Flarum\Locale {
    class LocaleManager
    {
        /**
         * @var Translator
         */
        protected $translator;
        protected $locales = [];
        protected $js = [];
        protected $css = [];
        /**
         * @var string
         */
        protected $cacheDir;
        public function __construct(\Flarum\Locale\Translator $translator, string $cacheDir = null)
        {
        }
        public function getLocale() : string
        {
        }
        public function setLocale(string $locale)
        {
        }
        public function addLocale(string $locale, string $name)
        {
        }
        public function getLocales() : array
        {
        }
        public function hasLocale(string $locale) : bool
        {
        }
        public function addTranslations(string $locale, $file, string $module = null)
        {
        }
        public function addJsFile(string $locale, string $js)
        {
        }
        public function getJsFiles(string $locale) : array
        {
        }
        public function addCssFile(string $locale, string $css)
        {
        }
        public function getCssFiles(string $locale) : array
        {
        }
        public function getTranslator() : \Flarum\Locale\Translator
        {
        }
        public function setTranslator(\Flarum\Locale\Translator $translator)
        {
        }
        public function clearCache()
        {
        }
    }
    class LocaleServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        private function getDefaultLocale(\Illuminate\Contracts\Container\Container $container) : string
        {
        }
        private function getCacheDir(\Illuminate\Contracts\Container\Container $container) : string
        {
        }
    }
    class PrefixedYamlFileLoader extends \Symfony\Component\Translation\Loader\YamlFileLoader
    {
        /**
         * {@inheritdoc}
         */
        public function load($resource, $locale, $domain = 'messages')
        {
        }
    }
    class Translator extends \Symfony\Component\Translation\Translator implements \Illuminate\Contracts\Translation\Translator
    {
        const REFERENCE_REGEX = '/^=>\\s*([a-z0-9_\\-\\.]+)$/i';
        public function get($key, array $replace = [], $locale = null)
        {
        }
        public function choice($key, $number, array $replace = [], $locale = null)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getCatalogue($locale = null)
        {
        }
        /**
         * @param MessageCatalogueInterface $catalogue
         */
        private function parseCatalogue(\Symfony\Component\Translation\MessageCatalogueInterface $catalogue)
        {
        }
        /**
         * @param MessageCatalogueInterface $catalogue
         * @param string $id
         * @param string $domain
         * @return string
         */
        private function getTranslation(\Symfony\Component\Translation\MessageCatalogueInterface $catalogue, $id, $domain)
        {
        }
        public function setLocale($locale)
        {
        }
    }
}
namespace Flarum\Mail {
    /**
     * An interface for a mail service.
     *
     * This interface provides all methods necessary for configuring, checking and
     * using one of Laravel's various email drivers throughout Flarum.
     *
     * @public
     */
    interface DriverInterface
    {
        /**
         * Provide a list of settings for this driver.
         *
         * The list must be an array of field names (keys) mapping to their type
         * (the empty string "" for a text field; or an array of possible values for
         * a dropdown field).
         */
        public function availableSettings() : array;
        /**
         * Ensure the given settings are enough to send emails.
         *
         * This method is responsible for determining whether the user-provided
         * values stored in Flarum's settings are "valid" as far as a simple
         * inspection of these values can determine it. Of course, this does not
         * mean that the mail server or API will actually accept e.g. credentials.
         *
         * Any errors must be wrapped in a {@see \Illuminate\Support\MessageBag}.
         * If there are no errors, an empty instance can be returned. In the
         * presence of validation problems with the configured mail driver, Flarum
         * will fall back to its no-op {@see \Flarum\Mail\NullDriver}.
         */
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag;
        /**
         * Does this driver actually send out emails?
         */
        public function canSend() : bool;
        /**
         * Build a mail transport based on Flarum's current settings.
         */
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport;
    }
}
namespace Flarum\Queue {
    class AbstractJob implements \Illuminate\Contracts\Queue\ShouldQueue
    {
        use \Illuminate\Queue\InteractsWithQueue;
        use \Illuminate\Bus\Queueable;
        use \Illuminate\Queue\SerializesModels;
    }
}
namespace Flarum\Mail\Job {
    class SendRawEmailJob extends \Flarum\Queue\AbstractJob
    {
        private $email;
        private $subject;
        private $body;
        public function __construct(string $email, string $subject, string $body)
        {
        }
        public function handle(\Illuminate\Contracts\Mail\Mailer $mailer)
        {
        }
    }
}
namespace Flarum\Mail {
    class LogDriver implements \Flarum\Mail\DriverInterface
    {
        /**
         * @var LoggerInterface
         */
        private $logger;
        public function __construct(\Psr\Log\LoggerInterface $logger)
        {
        }
        public function availableSettings() : array
        {
        }
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag
        {
        }
        public function canSend() : bool
        {
        }
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport
        {
        }
    }
    class MailgunDriver implements \Flarum\Mail\DriverInterface
    {
        public function availableSettings() : array
        {
        }
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag
        {
        }
        public function canSend() : bool
        {
        }
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport
        {
        }
    }
    class MailServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        public function register()
        {
        }
    }
    class NullDriver implements \Flarum\Mail\DriverInterface
    {
        public function availableSettings() : array
        {
        }
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag
        {
        }
        public function canSend() : bool
        {
        }
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport
        {
        }
    }
    class SendmailDriver implements \Flarum\Mail\DriverInterface
    {
        public function availableSettings() : array
        {
        }
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag
        {
        }
        public function canSend() : bool
        {
        }
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport
        {
        }
    }
    class SmtpDriver implements \Flarum\Mail\DriverInterface
    {
        public function availableSettings() : array
        {
        }
        public function validate(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Validation\Factory $validator) : \Illuminate\Support\MessageBag
        {
        }
        public function canSend() : bool
        {
        }
        public function buildTransport(\Flarum\Settings\SettingsRepositoryInterface $settings) : \Swift_Transport
        {
        }
    }
}
namespace Flarum\Notification\Blueprint {
    /**
     * A notification BlueprintInterface, when instantiated, represents a notification about
     * something. The blueprint is used by the NotificationSyncer to commit the
     * notification to the database.
     */
    interface BlueprintInterface
    {
        /**
         * Get the user that sent the notification.
         *
         * @return User|null
         */
        public function getFromUser();
        /**
         * Get the model that is the subject of this activity.
         *
         * @return AbstractModel|null
         */
        public function getSubject();
        /**
         * Get the data to be stored in the notification.
         *
         * @return array|null
         */
        public function getData();
        /**
         * Get the serialized type of this activity.
         *
         * @return string
         */
        public static function getType();
        /**
         * Get the name of the model class for the subject of this activity.
         *
         * @return string
         */
        public static function getSubjectModel();
    }
    class DiscussionRenamedBlueprint implements \Flarum\Notification\Blueprint\BlueprintInterface
    {
        /**
         * @var \Flarum\Post\DiscussionRenamedPost
         */
        protected $post;
        /**
         * @param DiscussionRenamedPost $post
         */
        public function __construct(\Flarum\Post\DiscussionRenamedPost $post)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getFromUser()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getSubject()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getData()
        {
        }
        /**
         * {@inheritdoc}
         */
        public static function getType()
        {
        }
        /**
         * {@inheritdoc}
         */
        public static function getSubjectModel()
        {
        }
    }
}
namespace Flarum\Notification\Command {
    class ReadAllNotifications
    {
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * @param User $actor The user performing the action.
         */
        public function __construct(\Flarum\User\User $actor)
        {
        }
    }
    class ReadAllNotificationsHandler
    {
        /**
         * @var NotificationRepository
         */
        protected $notifications;
        /**
         * @param NotificationRepository $notifications
         */
        public function __construct(\Flarum\Notification\NotificationRepository $notifications)
        {
        }
        /**
         * @param ReadAllNotifications $command
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Notification\Command\ReadAllNotifications $command)
        {
        }
    }
    class ReadNotification
    {
        /**
         * The ID of the notification to mark as read.
         *
         * @var int
         */
        public $notificationId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * @param int $notificationId The ID of the notification to mark as read.
         * @param User $actor The user performing the action.
         */
        public function __construct($notificationId, \Flarum\User\User $actor)
        {
        }
    }
    class ReadNotificationHandler
    {
        /**
         * @param ReadNotification $command
         * @return \Flarum\Notification\Notification
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Notification\Command\ReadNotification $command)
        {
        }
    }
}
namespace Flarum\Notification\Driver {
    interface NotificationDriverInterface
    {
        /**
         * Conditionally sends a notification to users, generally using a queue.
         *
         * @param BlueprintInterface $blueprint
         * @param User[] $users
         * @return void
         */
        public function send(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint, array $users) : void;
        /**
         * Logic for registering a notification type, generally used for adding a user preference.
         *
         * @param string $blueprintClass
         * @param array $driversEnabledByDefault
         * @return void
         */
        public function registerType(string $blueprintClass, array $driversEnabledByDefault) : void;
    }
    class AlertNotificationDriver implements \Flarum\Notification\Driver\NotificationDriverInterface
    {
        /**
         * @var Queue
         */
        private $queue;
        public function __construct(\Illuminate\Contracts\Queue\Queue $queue)
        {
        }
        /**
         * {@inheritDoc}
         */
        public function send(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint, array $users) : void
        {
        }
        /**
         * {@inheritdoc}
         */
        public function registerType(string $blueprintClass, array $driversEnabledByDefault) : void
        {
        }
    }
    class EmailNotificationDriver implements \Flarum\Notification\Driver\NotificationDriverInterface
    {
        /**
         * @var Queue
         */
        private $queue;
        public function __construct(\Illuminate\Contracts\Queue\Queue $queue)
        {
        }
        /**
         * {@inheritDoc}
         */
        public function send(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint, array $users) : void
        {
        }
        /**
         * Mail a notification to a list of users.
         *
         * @param MailableInterface $blueprint
         * @param User[] $recipients
         */
        protected function mailNotifications(\Flarum\Notification\MailableInterface $blueprint, array $recipients)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function registerType(string $blueprintClass, array $driversEnabledByDefault) : void
        {
        }
    }
}
namespace Flarum\Notification\Job {
    class SendEmailNotificationJob extends \Flarum\Queue\AbstractJob
    {
        /**
         * @var MailableInterface
         */
        private $blueprint;
        /**
         * @var User
         */
        private $recipient;
        public function __construct(\Flarum\Notification\MailableInterface $blueprint, \Flarum\User\User $recipient)
        {
        }
        public function handle(\Flarum\Notification\NotificationMailer $mailer)
        {
        }
    }
    class SendNotificationsJob extends \Flarum\Queue\AbstractJob
    {
        /**
         * @var BlueprintInterface
         */
        private $blueprint;
        /**
         * @var User[]
         */
        private $recipients;
        public function __construct(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint, array $recipients = [])
        {
        }
        public function handle()
        {
        }
    }
}
namespace Flarum\Notification {
    interface MailableInterface
    {
        /**
         * Get the name of the view to construct a notification email with.
         *
         * @return string
         */
        public function getEmailView();
        /**
         * Get the subject line for a notification email.
         *
         * @param TranslatorInterface $translator
         *
         * @return string
         */
        public function getEmailSubject(\Symfony\Contracts\Translation\TranslatorInterface $translator);
    }
    /**
     * Models a notification record in the database.
     *
     * A notification record is associated with a user, and shows up in their
     * notification list. A notification indicates that something has happened that
     * the user should know about, like if a user's discussion was renamed by
     * someone else.
     *
     * Each notification record has a *type*. The type determines how the record
     * looks in the notifications list, and what *subject* is associated with it.
     * For example, the 'discussionRenamed' notification type represents that
     * someone renamed a user's discussion. Its subject is a discussion, of which
     * the ID is stored in the `subject_id` column.
     *
     * @property int $id
     * @property int $user_id
     * @property int|null $from_user_id
     * @property string $type
     * @property int|null $subject_id
     * @property mixed|null $data
     * @property \Carbon\Carbon $created_at
     * @property \Carbon\Carbon $read_at
     * @property \Carbon\Carbon $deleted_at
     * @property \Flarum\User\User|null $user
     * @property \Flarum\User\User|null $fromUser
     * @property \Flarum\Database\AbstractModel|null $subject
     */
    class Notification extends \Flarum\Database\AbstractModel
    {
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at', 'read_at'];
        /**
         * A map of notification types and the model classes to use for their
         * subjects. For example, the 'discussionRenamed' notification type, which
         * represents that a user's discussion was renamed, has the subject model
         * class 'Flarum\Discussion\Discussion'.
         *
         * @var array
         */
        protected static $subjectModels = [];
        /**
         * Mark a notification as read.
         *
         * @return void
         */
        public function read()
        {
        }
        /**
         * When getting the data attribute, unserialize the JSON stored in the
         * database into a plain array.
         *
         * @param string $value
         * @return mixed
         */
        public function getDataAttribute($value)
        {
        }
        /**
         * When setting the data attribute, serialize it into JSON for storage in
         * the database.
         *
         * @param mixed $value
         */
        public function setDataAttribute($value)
        {
        }
        /**
         * Get the subject model for this notification record by looking up its
         * type in our subject model map.
         *
         * @return string|null
         */
        public function getSubjectModelAttribute()
        {
        }
        /**
         * Define the relationship with the notification's recipient.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Define the relationship with the notification's sender.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function fromUser()
        {
        }
        /**
         * Define the relationship with the notification's subject.
         *
         * @return \Illuminate\Database\Eloquent\Relations\MorphTo
         */
        public function subject()
        {
        }
        /**
         * Scope the query to include only notifications whose subjects are visible
         * to the given user.
         *
         * @param Builder $query
         * @return Builder
         */
        public function scopeWhereSubjectVisibleTo(\Illuminate\Database\Eloquent\Builder $query, \Flarum\User\User $actor)
        {
        }
        /**
         * Scope the query to include only notifications that have the given
         * subject.
         *
         * @param Builder $query
         * @param object $model
         * @return Builder
         */
        public function scopeWhereSubject(\Illuminate\Database\Eloquent\Builder $query, $model)
        {
        }
        /**
         * Scope the query to include only notification types that use the given
         * subject model.
         *
         * @param Builder $query
         * @param string $class
         * @return Builder
         */
        public function scopeWhereSubjectModel(\Illuminate\Database\Eloquent\Builder $query, string $class)
        {
        }
        /**
         * Scope the query to find all records matching the given blueprint.
         *
         * @param Builder $query
         * @param BlueprintInterface $blueprint
         * @return Builder
         */
        public function scopeMatchingBlueprint(\Illuminate\Database\Eloquent\Builder $query, \Flarum\Notification\Blueprint\BlueprintInterface $blueprint)
        {
        }
        /**
         * Send notifications to the given recipients.
         *
         * @param User[] $recipients
         * @param BlueprintInterface $blueprint
         */
        public static function notify(array $recipients, \Flarum\Notification\Blueprint\BlueprintInterface $blueprint)
        {
        }
        /**
         * Get the type-to-subject-model map.
         *
         * @return array
         */
        public static function getSubjectModels()
        {
        }
        /**
         * Set the subject model for the given notification type.
         *
         * @param string $type The notification type.
         * @param string $subjectModel The class name of the subject model for that
         *     type.
         * @return void
         */
        public static function setSubjectModel($type, $subjectModel)
        {
        }
        private static function getBlueprintAttributes(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint) : array
        {
        }
    }
    class NotificationMailer
    {
        /**
         * @var Mailer
         */
        protected $mailer;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param Mailer $mailer
         * @param TranslatorInterface $translator
         */
        public function __construct(\Illuminate\Contracts\Mail\Mailer $mailer, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        /**
         * @param MailableInterface $blueprint
         * @param User $user
         */
        public function send(\Flarum\Notification\MailableInterface $blueprint, \Flarum\User\User $user)
        {
        }
    }
    class NotificationRepository
    {
        /**
         * Find a user's notifications.
         *
         * @param User $user
         * @param int|null $limit
         * @param int $offset
         * @return \Illuminate\Database\Eloquent\Collection
         */
        public function findByUser(\Flarum\User\User $user, $limit = null, $offset = 0)
        {
        }
        /**
         * Mark all of a user's notifications as read.
         *
         * @param User $user
         *
         * @return void
         */
        public function markAllAsRead(\Flarum\User\User $user)
        {
        }
    }
    class NotificationServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * Register notification drivers.
         */
        protected function setNotificationDrivers(\Illuminate\Contracts\Container\Container $container)
        {
        }
        /**
         * Register notification types.
         */
        protected function setNotificationTypes(\Illuminate\Contracts\Container\Container $container)
        {
        }
        protected function addType(string $blueprint, array $driversEnabledByDefault)
        {
        }
    }
    /**
     * The Notification Syncer commits notification blueprints to the database, and
     * sends them via email depending on user preference. Where a blueprint
     * represents a single notification, the syncer associates it with a particular
     * user(s) and makes it available in their inbox.
     */
    class NotificationSyncer
    {
        /**
         * Whether or not notifications are being limited to one per user.
         *
         * @var bool
         */
        protected static $onePerUser = false;
        /**
         * An internal list of user IDs that notifications have been sent to.
         *
         * @var int[]
         */
        protected static $sentTo = [];
        /**
         * A map of notification drivers.
         *
         * @var NotificationDriverInterface[]
         */
        protected static $notificationDrivers = [];
        /**
         * @var array
         */
        protected static $beforeSendingCallbacks = [];
        /**
         * Sync a notification so that it is visible to the specified users, and not
         * visible to anyone else. If it is being made visible for the first time,
         * attempt to send the user an email.
         *
         * @param \Flarum\Notification\Blueprint\BlueprintInterface $blueprint
         * @param User[] $users
         * @return void
         */
        public function sync(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint, array $users)
        {
        }
        /**
         * Delete a notification for all users.
         *
         * @param \Flarum\Notification\Blueprint\BlueprintInterface $blueprint
         * @return void
         */
        public function delete(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint)
        {
        }
        /**
         * Restore a notification for all users.
         *
         * @param BlueprintInterface $blueprint
         * @return void
         */
        public function restore(\Flarum\Notification\Blueprint\BlueprintInterface $blueprint)
        {
        }
        /**
         * Limit notifications to one per user for the entire duration of the given
         * callback.
         *
         * @param callable $callback
         * @return void
         */
        public function onePerUser(callable $callback)
        {
        }
        /**
         * Set the deleted status of a list of notification records.
         *
         * @param int[] $ids
         * @param bool $isDeleted
         */
        protected function setDeleted(array $ids, $isDeleted)
        {
        }
        /**
         * Adds a notification driver to the list.
         *
         * @param string $driverName
         * @param NotificationDriverInterface $driver
         *
         * @internal
         */
        public static function addNotificationDriver(string $driverName, \Flarum\Notification\Driver\NotificationDriverInterface $driver) : void
        {
        }
        /**
         * @return NotificationDriverInterface[]
         */
        public static function getNotificationDrivers() : array
        {
        }
        /**
         * @param callable|string $callback
         *
         * @internal
         */
        public static function beforeSending($callback) : void
        {
        }
    }
}
namespace Flarum\Post {
    /**
     * @property int $id
     * @property int $discussion_id
     * @property int $number
     * @property \Carbon\Carbon $created_at
     * @property int|null $user_id
     * @property string|null $type
     * @property string|null $content
     * @property \Carbon\Carbon|null $edited_at
     * @property int|null $edited_user_id
     * @property \Carbon\Carbon|null $hidden_at
     * @property int|null $hidden_user_id
     * @property \Flarum\Discussion\Discussion|null $discussion
     * @property User|null $user
     * @property User|null $editedUser
     * @property User|null $hiddenUser
     * @property string $ip_address
     * @property bool $is_private
     */
    class Post extends \Flarum\Database\AbstractModel
    {
        use \Flarum\Foundation\EventGeneratorTrait;
        use \Flarum\Database\ScopeVisibilityTrait;
        protected $table = 'posts';
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at', 'edited_at', 'hidden_at'];
        /**
         * The attributes that should be cast to native types.
         *
         * @var array
         */
        protected $casts = ['is_private' => 'boolean'];
        /**
         * A map of post types, as specified in the `type` column, to their
         * classes.
         *
         * @var array
         */
        protected static $models = [];
        /**
         * The type of post this is, to be stored in the posts table.
         *
         * Should be overwritten by subclasses with the value that is
         * to be stored in the database, which will then be used for
         * mapping the hydrated model instance to the proper subtype.
         *
         * @var string
         */
        public static $type = '';
        /**
         * {@inheritdoc}
         */
        public static function boot()
        {
        }
        /**
         * Determine whether or not this post is visible to the given user.
         *
         * @param User $user
         * @return bool
         */
        public function isVisibleTo(\Flarum\User\User $user)
        {
        }
        /**
         * Define the relationship with the post's discussion.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function discussion()
        {
        }
        /**
         * Define the relationship with the post's author.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Define the relationship with the user who edited the post.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function editedUser()
        {
        }
        /**
         * Define the relationship with the user who hid the post.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function hiddenUser()
        {
        }
        /**
         * Get all posts, regardless of their type, by removing the
         * `RegisteredTypesScope` global scope constraints applied on this model.
         *
         * @param Builder $query
         * @return Builder
         */
        public function scopeAllTypes(\Illuminate\Database\Eloquent\Builder $query)
        {
        }
        /**
         * Create a new model instance according to the post's type.
         *
         * @param array $attributes
         * @param string|null $connection
         * @return static|object
         */
        public function newFromBuilder($attributes = [], $connection = null)
        {
        }
        /**
         * Get the type-to-model map.
         *
         * @return array
         */
        public static function getModels()
        {
        }
        /**
         * Set the model for the given post type.
         *
         * @param string $type The post type.
         * @param string $model The class name of the model for that type.
         * @return void
         *
         * @internal
         */
        public static function setModel(string $type, string $model)
        {
        }
    }
    /**
     * @property array $content
     */
    abstract class AbstractEventPost extends \Flarum\Post\Post
    {
        /**
         * Unserialize the content attribute from the database's JSON value.
         *
         * @param string $value
         * @return array
         */
        public function getContentAttribute($value)
        {
        }
        /**
         * Serialize the content attribute to be stored in the database as JSON.
         *
         * @param string $value
         */
        public function setContentAttribute($value)
        {
        }
    }
}
namespace Flarum\Post\Access {
    class PostPolicy extends \Flarum\User\Access\AbstractPolicy
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @param SettingsRepositoryInterface $settings
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings)
        {
        }
        /**
         * @param User $actor
         * @param string $ability
         * @param \Flarum\Post\Post $post
         * @return bool|null
         */
        public function can(\Flarum\User\User $actor, $ability, \Flarum\Post\Post $post)
        {
        }
        /**
         * @param User $actor
         * @param Post $post
         * @return bool|null
         */
        public function edit(\Flarum\User\User $actor, \Flarum\Post\Post $post)
        {
        }
        /**
         * @param User $actor
         * @param Post $post
         * @return bool|null
         */
        public function hide(\Flarum\User\User $actor, \Flarum\Post\Post $post)
        {
        }
    }
    class ScopePostVisibility
    {
        /**
         * @param User $actor
         * @param Builder $query
         */
        public function __invoke(\Flarum\User\User $actor, $query)
        {
        }
    }
}
namespace Flarum\Post\Command {
    class DeletePost
    {
        /**
         * The ID of the post to delete.
         *
         * @var int
         */
        public $postId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any other user input associated with the action. This is unused by
         * default, but may be used by extensions.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $postId The ID of the post to delete.
         * @param User $actor The user performing the action.
         * @param array $data Any other user input associated with the action. This
         *     is unused by default, but may be used by extensions.
         */
        public function __construct($postId, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
    class DeletePostHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\Post\PostRepository
         */
        protected $posts;
        /**
         * @param Dispatcher $events
         * @param \Flarum\Post\PostRepository $posts
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Post\PostRepository $posts)
        {
        }
        /**
         * @param DeletePost $command
         * @return \Flarum\Post\Post
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Post\Command\DeletePost $command)
        {
        }
    }
    class EditPost
    {
        /**
         * The ID of the post to edit.
         *
         * @var int
         */
        public $postId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the post.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $postId The ID of the post to edit.
         * @param User $actor The user performing the action.
         * @param array $data The attributes to update on the post.
         */
        public function __construct($postId, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class EditPostHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\Post\PostRepository
         */
        protected $posts;
        /**
         * @var \Flarum\Post\PostValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param PostRepository $posts
         * @param \Flarum\Post\PostValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Post\PostRepository $posts, \Flarum\Post\PostValidator $validator)
        {
        }
        /**
         * @param EditPost $command
         * @return \Flarum\Post\Post
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Post\Command\EditPost $command)
        {
        }
    }
    class PostReply
    {
        /**
         * The ID of the discussion to post the reply to.
         *
         * @var int
         */
        public $discussionId;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to assign to the new post.
         *
         * @var array
         */
        public $data;
        /**
         * The IP address of the actor.
         *
         * @var string
         */
        public $ipAddress;
        /**
         * @param int $discussionId The ID of the discussion to post the reply to.
         * @param User $actor The user who is performing the action.
         * @param array $data The attributes to assign to the new post.
         * @param string $ipAddress The IP address of the actor.
         */
        public function __construct($discussionId, \Flarum\User\User $actor, array $data, $ipAddress = null)
        {
        }
    }
    class PostReplyHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var DiscussionRepository
         */
        protected $discussions;
        /**
         * @var \Flarum\Notification\NotificationSyncer
         */
        protected $notifications;
        /**
         * @var \Flarum\Post\PostValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param DiscussionRepository $discussions
         * @param \Flarum\Notification\NotificationSyncer $notifications
         * @param PostValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Discussion\DiscussionRepository $discussions, \Flarum\Notification\NotificationSyncer $notifications, \Flarum\Post\PostValidator $validator)
        {
        }
        /**
         * @param PostReply $command
         * @return CommentPost
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\Post\Command\PostReply $command)
        {
        }
    }
}
namespace Flarum\Post {
    /**
     * A standard comment in a discussion.
     *
     * @property string $parsed_content
     */
    class CommentPost extends \Flarum\Post\Post
    {
        /**
         * {@inheritdoc}
         */
        public static $type = 'comment';
        /**
         * The text formatter instance.
         *
         * @var \Flarum\Formatter\Formatter
         */
        protected static $formatter;
        /**
         * Create a new instance in reply to a discussion.
         *
         * @param int $discussionId
         * @param string $content
         * @param int $userId
         * @param string $ipAddress
         * @return static
         */
        public static function reply($discussionId, $content, $userId, $ipAddress)
        {
        }
        /**
         * Revise the post's content.
         *
         * @param string $content
         * @param User $actor
         * @return $this
         */
        public function revise($content, \Flarum\User\User $actor)
        {
        }
        /**
         * Hide the post.
         *
         * @param User $actor
         * @return $this
         */
        public function hide(\Flarum\User\User $actor = null)
        {
        }
        /**
         * Restore the post.
         *
         * @return $this
         */
        public function restore()
        {
        }
        /**
         * Unparse the parsed content.
         *
         * @param string $value
         * @return string
         */
        public function getContentAttribute($value)
        {
        }
        /**
         * Get the parsed/raw content.
         *
         * @return string
         */
        public function getParsedContentAttribute()
        {
        }
        /**
         * Parse the content before it is saved to the database.
         *
         * @param string $value
         */
        public function setContentAttribute($value)
        {
        }
        /**
         * Set the parsed/raw content.
         *
         * @param string $value
         */
        public function setParsedContentAttribute($value)
        {
        }
        /**
         * Get the content rendered as HTML.
         *
         * @param ServerRequestInterface $request
         * @return string
         */
        public function formatContent(\Psr\Http\Message\ServerRequestInterface $request = null)
        {
        }
        /**
         * Get the text formatter instance.
         *
         * @return \Flarum\Formatter\Formatter
         */
        public static function getFormatter()
        {
        }
        /**
         * Set the text formatter instance.
         *
         * @param \Flarum\Formatter\Formatter $formatter
         */
        public static function setFormatter(\Flarum\Formatter\Formatter $formatter)
        {
        }
    }
    /**
     * A post that has the ability to be merged into an adjacent post.
     *
     * This is only implemented by certain types of posts. For example,
     * if a "discussion renamed" post is posted immediately after another
     * "discussion renamed" post, then the new one will be merged into the old one.
     */
    interface MergeableInterface
    {
        /**
         * Save the model, given that it is going to appear immediately after the
         * passed model.
         *
         * @param \Flarum\Post\Post|null $previous
         * @return Post The model resulting after the merge. If the merge is
         *     unsuccessful, this should be the current model instance. Otherwise,
         *     it should be the model that was merged into.
         */
        public function saveAfter(\Flarum\Post\Post $previous = null);
    }
    /**
     * A post which indicates that a discussion's title was changed.
     *
     * The content is stored as a sequential array containing the old title and the
     * new title.
     */
    class DiscussionRenamedPost extends \Flarum\Post\AbstractEventPost implements \Flarum\Post\MergeableInterface
    {
        /**
         * {@inheritdoc}
         */
        public static $type = 'discussionRenamed';
        /**
         * {@inheritdoc}
         */
        public function saveAfter(\Flarum\Post\Post $previous = null)
        {
        }
        /**
         * Create a new instance in reply to a discussion.
         *
         * @param int $discussionId
         * @param int $userId
         * @param string $oldTitle
         * @param string $newTitle
         * @return static
         */
        public static function reply($discussionId, $userId, $oldTitle, $newTitle)
        {
        }
        /**
         * Build the content attribute.
         *
         * @param string $oldTitle The old title of the discussion.
         * @param string $newTitle The new title of the discussion.
         * @return array
         */
        protected static function buildContent($oldTitle, $newTitle)
        {
        }
    }
}
namespace Flarum\Post\Event {
    class Deleted
    {
        /**
         * @var \Flarum\Post\Post
         */
        public $post;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Post\Post $post
         */
        public function __construct(\Flarum\Post\Post $post, \Flarum\User\User $actor = null)
        {
        }
    }
    class Deleting
    {
        /**
         * The post that is going to be deleted.
         *
         * @var \Flarum\Post\Post
         */
        public $post;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any user input associated with the command.
         *
         * @var array
         */
        public $data;
        /**
         * @param \Flarum\Post\Post $post
         * @param User $actor
         * @param array $data
         */
        public function __construct(\Flarum\Post\Post $post, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class Hidden
    {
        /**
         * @var CommentPost
         */
        public $post;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param CommentPost $post
         */
        public function __construct(\Flarum\Post\CommentPost $post, \Flarum\User\User $actor = null)
        {
        }
    }
    class Posted
    {
        /**
         * @var \Flarum\Post\Post
         */
        public $post;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Post\Post $post
         */
        public function __construct(\Flarum\Post\Post $post, \Flarum\User\User $actor = null)
        {
        }
    }
    class Restored
    {
        /**
         * @var \Flarum\Post\CommentPost
         */
        public $post;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Post\CommentPost $post
         */
        public function __construct(\Flarum\Post\CommentPost $post, \Flarum\User\User $actor = null)
        {
        }
    }
    class Revised
    {
        /**
         * @var \Flarum\Post\CommentPost
         */
        public $post;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param \Flarum\Post\CommentPost $post
         */
        public function __construct(\Flarum\Post\CommentPost $post, \Flarum\User\User $actor = null)
        {
        }
    }
    class Saving
    {
        /**
         * The post that will be saved.
         *
         * @var \Flarum\Post\Post
         */
        public $post;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the post.
         *
         * @var array
         */
        public $data;
        /**
         * @param \Flarum\Post\Post $post
         * @param User $actor
         * @param array $data
         */
        public function __construct(\Flarum\Post\Post $post, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
}
namespace Flarum\Post\Exception {
    class FloodingException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
}
namespace Flarum\Post\Filter {
    class AuthorFilter implements \Flarum\Filter\FilterInterface
    {
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @param \Flarum\User\UserRepository $users
         */
        public function __construct(\Flarum\User\UserRepository $users)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
    class DiscussionFilter implements \Flarum\Filter\FilterInterface
    {
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
    class IdFilter implements \Flarum\Filter\FilterInterface
    {
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
    class NumberFilter implements \Flarum\Filter\FilterInterface
    {
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
    class PostFilterer extends \Flarum\Filter\AbstractFilterer
    {
        /**
         * @var PostRepository
         */
        protected $posts;
        /**
         * @param PostRepository $posts
         * @param array $filters
         * @param array $filterMutators
         */
        public function __construct(\Flarum\Post\PostRepository $posts, array $filters, array $filterMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
    class TypeFilter implements \Flarum\Filter\FilterInterface
    {
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
    }
}
namespace Flarum\Post {
    class PostRepository
    {
        /**
         * Get a new query builder for the posts table.
         *
         * @return Builder
         */
        public function query()
        {
        }
        /**
         * @param User|null $user
         * @return Builder
         */
        protected function queryVisibleTo(\Flarum\User\User $user = null)
        {
        }
        /**
         * Find a post by ID, optionally making sure it is visible to a certain
         * user, or throw an exception.
         *
         * @param int $id
         * @param \Flarum\User\User $actor
         * @return \Flarum\Post\Post
         *
         * @throws \Illuminate\Database\Eloquent\ModelNotFoundException
         */
        public function findOrFail($id, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Find posts that match certain conditions, optionally making sure they
         * are visible to a certain user, and/or using other criteria.
         *
         * @param array $where
         * @param \Flarum\User\User|null $actor
         * @param array $sort
         * @param int $count
         * @param int $start
         * @return \Illuminate\Database\Eloquent\Collection
         */
        public function findWhere(array $where = [], \Flarum\User\User $actor = null, $sort = [], $count = null, $start = 0)
        {
        }
        /**
         * Filter a list of post IDs to only include posts that are visible to a
         * certain user.
         *
         * @param array $ids
         * @param User $actor
         * @return array
         */
        public function filterVisibleIds(array $ids, \Flarum\User\User $actor)
        {
        }
        /**
         * Get the position within a discussion where a post with a certain number
         * is. If the post with that number does not exist, the index of the
         * closest post to it will be returned.
         *
         * @param int $discussionId
         * @param int $number
         * @param \Flarum\User\User|null $actor
         * @return int
         */
        public function getIndexForNumber($discussionId, $number, \Flarum\User\User $actor = null)
        {
        }
        /**
         * @param array $ids
         * @param User|null $actor
         * @return Builder
         */
        protected function queryIds(array $ids, \Flarum\User\User $actor = null)
        {
        }
    }
    class PostServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        public function boot(\Flarum\Formatter\Formatter $formatter)
        {
        }
        protected function setPostTypes()
        {
        }
    }
    class PostValidator extends \Flarum\Foundation\AbstractValidator
    {
        protected $rules = ['content' => ['required', 'max:65535']];
    }
    class RegisteredTypesScope implements \Illuminate\Database\Eloquent\Scope
    {
        /**
         * Apply the scope to a given Eloquent query builder.
         *
         * @param Builder $builder
         * @param Model $post
         */
        public function apply(\Illuminate\Database\Eloquent\Builder $builder, \Illuminate\Database\Eloquent\Model $post)
        {
        }
    }
}
namespace Flarum\Query {
    /**
     * Represents the criteria that will determine the entire result set of a
     * query. The limit and offset are not included because they only determine
     * which part of the entire result set will be returned.
     */
    class QueryCriteria
    {
        /**
         * The user performing the query.
         *
         * @var User
         */
        public $actor;
        /**
         * Query params.
         *
         * @var array
         */
        public $query;
        /**
         * An array of sort-order pairs, where the column is the key, and the order
         * is the value. The order may be 'asc', 'desc', or an array of IDs to
         * order by.
         *
         * @var array
         */
        public $sort;
        /**
         * Is the sort for this request the default sort from the controller?
         * If false, the current request specifies a sort.
         *
         * @var bool
         */
        public $sortIsDefault;
        /**
         * @param User $actor The user performing the query.
         * @param array $query The query params.
         * @param array $sort An array of sort-order pairs, where the column is the
         *     key, and the order is the value. The order may be 'asc', 'desc', or
         *     an array of IDs to order by.
         */
        public function __construct(\Flarum\User\User $actor, $query, array $sort = null, bool $sortIsDefault = false)
        {
        }
    }
    class QueryResults
    {
        /**
         * @var Collection
         */
        protected $results;
        /**
         * @var bool
         */
        protected $areMoreResults;
        /**
         * @param Collection $results
         * @param bool $areMoreResults
         */
        public function __construct(\Illuminate\Database\Eloquent\Collection $results, $areMoreResults)
        {
        }
        /**
         * @return Collection
         */
        public function getResults()
        {
        }
        /**
         * @return bool
         */
        public function areMoreResults()
        {
        }
    }
}
namespace Flarum\Queue\Console {
    class ListenCommand extends \Illuminate\Queue\Console\ListenCommand
    {
        public function __construct(\Illuminate\Queue\Listener $listener)
        {
        }
    }
    class WorkCommand extends \Illuminate\Queue\Console\WorkCommand
    {
        protected function downForMaintenance()
        {
        }
    }
}
namespace Flarum\Queue {
    class ExceptionHandler implements \Illuminate\Contracts\Debug\ExceptionHandler
    {
        /**
         * @var LoggerInterface
         */
        private $logger;
        public function __construct(\Psr\Log\LoggerInterface $logger)
        {
        }
        /**
         * Report or log an exception.
         *
         * @param  Throwable $e
         * @return void
         */
        public function report(\Throwable $e)
        {
        }
        /**
         * Render an exception into an HTTP response.
         *
         * @param  \Illuminate\Http\Request $request
         * @param  Throwable               $e
         * @return \Symfony\Component\HttpFoundation\Response
         */
        public function render($request, \Throwable $e)
        {
        }
        /**
         * Render an exception to the console.
         *
         * @param  \Symfony\Component\Console\Output\OutputInterface $output
         * @param  Throwable                                        $e
         * @return void
         */
        public function renderForConsole($output, \Throwable $e)
        {
        }
        /**
         * Determine if the exception should be reported.
         *
         * @param  Throwable $e
         * @return bool
         */
        public function shouldReport(\Throwable $e)
        {
        }
    }
    class Listener extends \Illuminate\Queue\Listener
    {
        protected function addEnvironment($command, \Illuminate\Queue\ListenerOptions $options)
        {
        }
        protected function artisanBinary()
        {
        }
    }
    class QueueFactory implements \Illuminate\Contracts\Queue\Factory
    {
        /**
         * @var callable
         */
        private $factory;
        /**
         * The cached queue instance.
         *
         * @var \Illuminate\Contracts\Queue\Queue
         */
        private $queue;
        /**
         * QueueFactory constructor.
         *
         * Expects a callback that will be called to instantiate the queue adapter,
         * once requested by the application.
         *
         * @param callable $factory
         */
        public function __construct(callable $factory)
        {
        }
        /**
         * Resolve a queue connection instance.
         *
         * @param string $name
         * @return \Illuminate\Contracts\Queue\Queue
         */
        public function connection($name = null)
        {
        }
    }
    class QueueServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        protected $commands = [\Illuminate\Queue\Console\FlushFailedCommand::class, \Illuminate\Queue\Console\ForgetFailedCommand::class, \Flarum\Queue\Console\ListenCommand::class, \Illuminate\Queue\Console\ListFailedCommand::class, \Illuminate\Queue\Console\RestartCommand::class, \Illuminate\Queue\Console\RetryCommand::class, \Flarum\Queue\Console\WorkCommand::class];
        public function register()
        {
        }
        protected function registerCommands()
        {
        }
        public function boot(\Illuminate\Contracts\Events\Dispatcher $events, \Illuminate\Contracts\Container\Container $container)
        {
        }
    }
}
namespace Flarum\Search {
    /**
     * @internal
     */
    class GambitManager
    {
        /**
         * @var array
         */
        protected $gambits = [];
        /**
         * @var GambitInterface
         */
        protected $fulltextGambit;
        /**
         * @param GambitInterface $gambit
         */
        public function __construct(\Flarum\Search\GambitInterface $fulltextGambit)
        {
        }
        /**
         * Add a gambit.
         *
         * @param GambitInterface $gambit
         */
        public function add(\Flarum\Search\GambitInterface $gambit)
        {
        }
        /**
         * Apply gambits to a search, given a search query.
         *
         * @param SearchState $search
         * @param string $query
         */
        public function apply(\Flarum\Search\SearchState $search, $query)
        {
        }
        /**
         * Explode a search query into an array of bits.
         *
         * @param string $query
         * @return array
         */
        protected function explode($query)
        {
        }
        /**
         * @param SearchState $search
         * @param string $query
         * @return string
         */
        protected function applyGambits(\Flarum\Search\SearchState $search, $query)
        {
        }
        /**
         * @param SearchState $search
         * @param string $query
         */
        protected function applyFulltext(\Flarum\Search\SearchState $search, $query)
        {
        }
    }
    class SearchServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * @inheritDoc
         */
        public function register()
        {
        }
        public function boot(\Illuminate\Contracts\Container\Container $container)
        {
        }
    }
    class SearchState extends \Flarum\Query\AbstractQueryState
    {
        /**
         * @var GambitInterface[]
         */
        protected $activeGambits = [];
        /**
         * Get a list of the gambits that are active in this search.
         *
         * @return GambitInterface[]
         */
        public function getActiveGambits()
        {
        }
        /**
         * Add a gambit as being active in this search.
         *
         * @param GambitInterface $gambit
         * @return void
         */
        public function addActiveGambit(\Flarum\Search\GambitInterface $gambit)
        {
        }
    }
}
namespace Flarum\Settings {
    interface SettingsRepositoryInterface
    {
        public function all() : array;
        /**
         * @todo remove $default in 2.0
         *
         * @param $key
         * @param mixed $default: Deprecated
         * @return mixed
         */
        public function get($key, $default = null);
        public function set($key, $value);
        public function delete($keyLike);
    }
    class DatabaseSettingsRepository implements \Flarum\Settings\SettingsRepositoryInterface
    {
        protected $database;
        public function __construct(\Illuminate\Database\ConnectionInterface $connection)
        {
        }
        public function all() : array
        {
        }
        public function get($key, $default = null)
        {
        }
        public function set($key, $value)
        {
        }
        public function delete($key)
        {
        }
    }
    class DefaultSettingsRepository implements \Flarum\Settings\SettingsRepositoryInterface
    {
        protected $defaults;
        private $inner;
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $inner, \Illuminate\Support\Collection $defaults)
        {
        }
        public function get($key, $default = null)
        {
        }
        public function set($key, $value)
        {
        }
        public function delete($keyLike)
        {
        }
        public function all() : array
        {
        }
    }
}
namespace Flarum\Settings\Event {
    /**
     * Prepare settings for display in the client.
     *
     * This event is fired when settings have been retrieved from the database and
     * are being unserialized for display in the client.
     */
    class Deserializing
    {
        /**
         * The settings array to be unserialized.
         *
         * @var array
         */
        public $settings;
        /**
         * @param array $settings The settings array to be unserialized.
         */
        public function __construct(&$settings)
        {
        }
    }
    class Saved
    {
        /**
         * @var array
         */
        public $settings;
        /**
         * @param array $settings
         */
        public function __construct(array $settings)
        {
        }
    }
    class Saving
    {
        /**
         * @var array
         */
        public $settings;
        /**
         * @param array $settings
         */
        public function __construct(array &$settings)
        {
        }
    }
    class Serializing
    {
        /**
         * The settings key being saved.
         *
         * @var string
         */
        public $key;
        /**
         * The settings value to save.
         *
         * @var string
         */
        public $value;
        /**
         * @param string $key The settings key being saved.
         * @param string $value The settings value to save.
         */
        public function __construct($key, &$value)
        {
        }
    }
}
namespace Flarum\Settings {
    class MemoryCacheSettingsRepository implements \Flarum\Settings\SettingsRepositoryInterface
    {
        protected $inner;
        protected $isCached;
        protected $cache = [];
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $inner)
        {
        }
        public function all() : array
        {
        }
        public function get($key, $default = null)
        {
        }
        public function set($key, $value)
        {
        }
        public function delete($key)
        {
        }
    }
    /**
     * A settings repository decorator that allows overriding certain values.
     *
     * The `OverrideSettingsRepository` class decorates another
     * `SettingsRepositoryInterface` instance but allows certain settings to be
     * overridden with predefined values. It does not affect writing methods.
     *
     * Within Flarum, this can be used to test out new setting values in a system
     * before they are committed to the database.
     *
     * @see \Flarum\Forum\ValidateCustomLess For an example usage.
     */
    class OverrideSettingsRepository implements \Flarum\Settings\SettingsRepositoryInterface
    {
        protected $inner;
        protected $overrides = [];
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $inner, array $overrides)
        {
        }
        public function all() : array
        {
        }
        public function get($key, $default = null)
        {
        }
        public function set($key, $value)
        {
        }
        public function delete($key)
        {
        }
    }
    class SettingsServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        public function boot(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Settings\SettingsValidator $settingsValidator)
        {
        }
    }
    class SettingsValidator extends \Flarum\Foundation\AbstractValidator
    {
        /**
         * @var array
         */
        protected $rules = [];
        /**
         * These rules apply to all attributes.
         *
         * Entries in the default DB settings table are limited to 65,000
         * characters. We validate against this to avoid confusing errors.
         *
         * @var array
         */
        protected $globalRules = ['max:65000'];
        /**
         * Make a new validator instance for this model.
         *
         * @param array $attributes
         * @return \Illuminate\Validation\Validator
         */
        protected function makeValidator(array $attributes)
        {
        }
    }
    class UninstalledSettingsRepository implements \Flarum\Settings\SettingsRepositoryInterface
    {
        public function all() : array
        {
        }
        public function get($key, $default = null)
        {
        }
        public function set($key, $value)
        {
        }
        public function delete($keyLike)
        {
        }
    }
}
namespace Flarum\Update\Controller {
    class IndexController extends \Flarum\Http\Controller\AbstractHtmlController
    {
        /**
         * @var Factory
         */
        protected $view;
        /**
         * @param Factory $view
         */
        public function __construct(\Illuminate\Contracts\View\Factory $view)
        {
        }
        /**
         * @param Request $request
         * @return \Psr\Http\Message\ResponseInterface
         */
        public function render(\Psr\Http\Message\ServerRequestInterface $request)
        {
        }
    }
    class UpdateController implements \Psr\Http\Server\RequestHandlerInterface
    {
        protected $command;
        /**
         * @var Config
         */
        protected $config;
        /**
         * @param MigrateCommand $command
         * @param Config $config
         */
        public function __construct(\Flarum\Database\Console\MigrateCommand $command, \Flarum\Foundation\Config $config)
        {
        }
        /**
         * @param Request $request
         * @return ResponseInterface
         */
        public function handle(\Psr\Http\Message\ServerRequestInterface $request) : \Psr\Http\Message\ResponseInterface
        {
        }
    }
}
namespace Flarum\Update {
    class UpdateServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        public function boot()
        {
        }
        /**
         * @param RouteCollection     $routes
         * @param RouteHandlerFactory $route
         */
        protected function populateRoutes(\Flarum\Http\RouteCollection $routes, \Flarum\Http\RouteHandlerFactory $route)
        {
        }
    }
}
namespace Flarum\User\Access {
    /**
     * @internal
     */
    class Gate
    {
        protected const EVALUATION_CRITERIA_PRIORITY = [\Flarum\User\Access\AbstractPolicy::FORCE_DENY => false, \Flarum\User\Access\AbstractPolicy::FORCE_ALLOW => true, \Flarum\User\Access\AbstractPolicy::DENY => false, \Flarum\User\Access\AbstractPolicy::ALLOW => true];
        /**
         * @var Container
         */
        protected $container;
        /**
         * @var array
         */
        protected $policyClasses;
        /**
         * @var array
         */
        protected $policies;
        /**
         * @param Container $container
         * @param array $policyClasses
         */
        public function __construct(\Illuminate\Contracts\Container\Container $container, array $policyClasses)
        {
        }
        /**
         * Determine if the given ability should be granted for the current user.
         *
         * @param  User $actor
         * @param  string  $ability
         * @param  string|AbstractModel $model
         * @return bool
         */
        public function allows(\Flarum\User\User $actor, string $ability, $model) : bool
        {
        }
        /**
         * Get all policies for a given model and ability.
         */
        protected function getPolicies(string $model)
        {
        }
    }
    class ScopeUserVisibility
    {
        /**
         * @param User $actor
         * @param Builder $query
         */
        public function __invoke(\Flarum\User\User $actor, $query)
        {
        }
    }
    class UserPolicy extends \Flarum\User\Access\AbstractPolicy
    {
        /**
         * @param User $actor
         * @param string $ability
         * @return bool|null
         */
        public function can(\Flarum\User\User $actor, $ability)
        {
        }
        /**
         * @param User $actor
         * @param User $user
         */
        public function editCredentials(\Flarum\User\User $actor, \Flarum\User\User $user)
        {
        }
    }
}
namespace Flarum\User {
    class AccountActivationMailer
    {
        use \Flarum\User\AccountActivationMailerTrait;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Queue
         */
        protected $queue;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @param \Flarum\Settings\SettingsRepositoryInterface $settings
         * @param Queue $queue
         * @param UrlGenerator $url
         * @param TranslatorInterface $translator
         */
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Queue\Queue $queue, \Flarum\Http\UrlGenerator $url, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        public function handle(\Flarum\User\Event\Registered $event)
        {
        }
    }
    class AvatarUploader
    {
        /**
         * @var Filesystem
         */
        protected $uploadDir;
        public function __construct(\Illuminate\Contracts\Filesystem\Factory $filesystemFactory)
        {
        }
        /**
         * @param User $user
         * @param Image $image
         */
        public function upload(\Flarum\User\User $user, \Intervention\Image\Image $image)
        {
        }
        /**
         * Handle the removal of the old avatar file after a successful user save
         * We don't place this in remove() because otherwise we would call changeAvatarPath 2 times when uploading.
         * @param User $user
         */
        protected function removeFileAfterSave(\Flarum\User\User $user)
        {
        }
        /**
         * @param User $user
         */
        public function remove(\Flarum\User\User $user)
        {
        }
    }
    class AvatarValidator extends \Flarum\Foundation\AbstractValidator
    {
        /**
         * @var \Illuminate\Validation\Validator
         */
        protected $laravelValidator;
        /**
         * Throw an exception if a model is not valid.
         *
         * @param array $attributes
         */
        public function assertValid(array $attributes)
        {
        }
        protected function assertFileRequired(\Psr\Http\Message\UploadedFileInterface $file)
        {
        }
        protected function assertFileMimes(\Psr\Http\Message\UploadedFileInterface $file)
        {
        }
        protected function assertFileSize(\Psr\Http\Message\UploadedFileInterface $file)
        {
        }
        protected function raise($error, array $parameters = [], $rule = null)
        {
        }
        protected function getMaxSize()
        {
        }
        protected function getAllowedTypes()
        {
        }
    }
}
namespace Flarum\User\Command {
    class ConfirmEmail
    {
        /**
         * The email confirmation token.
         *
         * @var string
         */
        public $token;
        /**
         * @param string $token The email confirmation token.
         */
        public function __construct($token)
        {
        }
    }
    class ConfirmEmailHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @param \Flarum\User\UserRepository $users
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\User\UserRepository $users)
        {
        }
        /**
         * @param ConfirmEmail $command
         * @return \Flarum\User\User
         */
        public function handle(\Flarum\User\Command\ConfirmEmail $command)
        {
        }
    }
    class DeleteAvatar
    {
        /**
         * The ID of the user to delete the avatar of.
         *
         * @var int
         */
        public $userId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * @param int $userId The ID of the user to delete the avatar of.
         * @param User $actor The user performing the action.
         */
        public function __construct($userId, \Flarum\User\User $actor)
        {
        }
    }
    class DeleteAvatarHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @var AvatarUploader
         */
        protected $uploader;
        /**
         * @param Dispatcher $events
         * @param UserRepository $users
         * @param AvatarUploader $uploader
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\User\UserRepository $users, \Flarum\User\AvatarUploader $uploader)
        {
        }
        /**
         * @param DeleteAvatar $command
         * @return \Flarum\User\User
         * @throws \Flarum\User\Exception\PermissionDeniedException
         */
        public function handle(\Flarum\User\Command\DeleteAvatar $command)
        {
        }
    }
    class DeleteUser
    {
        /**
         * The ID of the user to delete.
         *
         * @var int
         */
        public $userId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any other user input associated with the action. This is unused by
         * default, but may be used by extensions.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $userId The ID of the user to delete.
         * @param User $actor The user performing the action.
         * @param array $data Any other user input associated with the action. This
         *     is unused by default, but may be used by extensions.
         */
        public function __construct($userId, \Flarum\User\User $actor, array $data = [])
        {
        }
    }
    class DeleteUserHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @param Dispatcher $events
         * @param UserRepository $users
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\User\UserRepository $users)
        {
        }
        /**
         * @param DeleteUser $command
         * @return \Flarum\User\User
         * @throws PermissionDeniedException
         */
        public function handle(\Flarum\User\Command\DeleteUser $command)
        {
        }
    }
    class EditUser
    {
        /**
         * The ID of the user to edit.
         *
         * @var int
         */
        public $userId;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the user.
         *
         * @var array
         */
        public $data;
        /**
         * @param int $userId The ID of the user to edit.
         * @param User $actor The user performing the action.
         * @param array $data The attributes to update on the user.
         */
        public function __construct($userId, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class EditUserHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @var UserValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param \Flarum\User\UserRepository $users
         * @param UserValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\User\UserRepository $users, \Flarum\User\UserValidator $validator)
        {
        }
        /**
         * @param EditUser $command
         * @return User
         * @throws \Flarum\User\Exception\PermissionDeniedException
         * @throws ValidationException
         */
        public function handle(\Flarum\User\Command\EditUser $command)
        {
        }
    }
    class RegisterUser
    {
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes of the new user.
         *
         * @var array
         */
        public $data;
        /**
         * @param User $actor The user performing the action.
         * @param array $data The attributes of the new user.
         */
        public function __construct(\Flarum\User\User $actor, array $data)
        {
        }
    }
    class RegisterUserHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var UserValidator
         */
        protected $userValidator;
        /**
         * @var AvatarUploader
         */
        protected $avatarUploader;
        /**
         * @var Factory
         */
        private $validator;
        /**
         * @param Dispatcher $events
         * @param SettingsRepositoryInterface $settings
         * @param UserValidator $validator
         * @param AvatarUploader $avatarUploader
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Settings\SettingsRepositoryInterface $settings, \Flarum\User\UserValidator $userValidator, \Flarum\User\AvatarUploader $avatarUploader, \Illuminate\Validation\Factory $validator)
        {
        }
        /**
         * @param RegisterUser $command
         * @return User
         * @throws PermissionDeniedException if signup is closed and the actor is
         *     not an administrator.
         * @throws ValidationException
         */
        public function handle(\Flarum\User\Command\RegisterUser $command)
        {
        }
        private function applyToken(\Flarum\User\User $user, \Flarum\User\RegistrationToken $token)
        {
        }
        /**
         * @throws InvalidArgumentException
         */
        private function uploadAvatarFromUrl(\Flarum\User\User $user, string $url)
        {
        }
        private function fulfillToken(\Flarum\User\User $user, \Flarum\User\RegistrationToken $token)
        {
        }
    }
    class RequestPasswordReset
    {
        /**
         * The email of the user to request a password reset for.
         *
         * @var string
         */
        public $email;
        /**
         * @param string $email The email of the user to request a password reset for.
         */
        public function __construct($email)
        {
        }
    }
    class RequestPasswordResetHandler
    {
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Queue
         */
        protected $queue;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        /**
         * @var Factory
         */
        protected $validatorFactory;
        /**
         * @param UserRepository $users
         * @param SettingsRepositoryInterface $settings
         * @param Queue $queue
         * @param UrlGenerator $url
         * @param TranslatorInterface $translator
         * @param Factory $validatorFactory
         */
        public function __construct(\Flarum\User\UserRepository $users, \Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Queue\Queue $queue, \Flarum\Http\UrlGenerator $url, \Symfony\Contracts\Translation\TranslatorInterface $translator, \Illuminate\Contracts\Validation\Factory $validatorFactory)
        {
        }
        /**
         * @param RequestPasswordReset $command
         * @return \Flarum\User\User
         * @throws ModelNotFoundException
         */
        public function handle(\Flarum\User\Command\RequestPasswordReset $command)
        {
        }
    }
    class UploadAvatar
    {
        /**
         * The ID of the user to upload the avatar for.
         *
         * @var int
         */
        public $userId;
        /**
         * The avatar file to upload.
         *
         * @var UploadedFileInterface
         */
        public $file;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * @param int $userId The ID of the user to upload the avatar for.
         * @param UploadedFileInterface $file The avatar file to upload.
         * @param User $actor The user performing the action.
         */
        public function __construct($userId, \Psr\Http\Message\UploadedFileInterface $file, \Flarum\User\User $actor)
        {
        }
    }
    class UploadAvatarHandler
    {
        use \Flarum\Foundation\DispatchEventsTrait;
        /**
         * @var \Flarum\User\UserRepository
         */
        protected $users;
        /**
         * @var AvatarUploader
         */
        protected $uploader;
        /**
         * @var \Flarum\User\AvatarValidator
         */
        protected $validator;
        /**
         * @param Dispatcher $events
         * @param UserRepository $users
         * @param AvatarUploader $uploader
         * @param AvatarValidator $validator
         */
        public function __construct(\Illuminate\Contracts\Events\Dispatcher $events, \Flarum\User\UserRepository $users, \Flarum\User\AvatarUploader $uploader, \Flarum\User\AvatarValidator $validator)
        {
        }
        /**
         * @param UploadAvatar $command
         * @return \Flarum\User\User
         * @throws \Flarum\User\Exception\PermissionDeniedException
         * @throws \Flarum\Foundation\ValidationException
         */
        public function handle(\Flarum\User\Command\UploadAvatar $command)
        {
        }
    }
}
namespace Flarum\User\DisplayName {
    /**
     * An interface for a display name driver.
     *
     * @public
     */
    interface DriverInterface
    {
        /**
         * Return a display name for a user.
         */
        public function displayName(\Flarum\User\User $user) : string;
    }
    /**
     * The default driver, which returns the user's username.
     */
    class UsernameDriver implements \Flarum\User\DisplayName\DriverInterface
    {
        public function displayName(\Flarum\User\User $user) : string
        {
        }
    }
}
namespace Flarum\User {
    class EmailConfirmationMailer
    {
        /**
         * @var SettingsRepositoryInterface
         */
        protected $settings;
        /**
         * @var Queue
         */
        protected $queue;
        /**
         * @var UrlGenerator
         */
        protected $url;
        /**
         * @var TranslatorInterface
         */
        protected $translator;
        public function __construct(\Flarum\Settings\SettingsRepositoryInterface $settings, \Illuminate\Contracts\Queue\Queue $queue, \Flarum\Http\UrlGenerator $url, \Symfony\Contracts\Translation\TranslatorInterface $translator)
        {
        }
        public function handle(\Flarum\User\Event\EmailChangeRequested $event)
        {
        }
        /**
         * @param User $user
         * @param string $email
         * @return EmailToken
         */
        protected function generateToken(\Flarum\User\User $user, $email)
        {
        }
        /**
         * Get the data that should be made available to email templates.
         *
         * @param User $user
         * @param string $email
         * @return array
         */
        protected function getEmailData(\Flarum\User\User $user, $email)
        {
        }
    }
    /**
     * @property string $token
     * @property int $user_id
     * @property \Carbon\Carbon $created_at
     * @property string $email
     */
    class EmailToken extends \Flarum\Database\AbstractModel
    {
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at'];
        /**
         * Use a custom primary key for this model.
         *
         * @var bool
         */
        public $incrementing = false;
        /**
         * {@inheritdoc}
         */
        protected $primaryKey = 'token';
        /**
         * Generate an email token for the specified user.
         *
         * @param string $email
         * @param int $userId
         *
         * @return static
         */
        public static function generate($email, $userId)
        {
        }
        /**
         * Define the relationship with the owner of this email token.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
        /**
         * Find the token with the given ID, and assert that it has not expired.
         *
         * @param \Illuminate\Database\Eloquent\Builder $query
         * @param string $id
         * @return static
         * @throws InvalidConfirmationTokenException
         */
        public function scopeValidOrFail($query, $id)
        {
        }
    }
}
namespace Flarum\User\Event {
    class Activated
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class AvatarChanged
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class AvatarDeleting
    {
        /**
         * The user whose avatar will be deleted.
         *
         * @var User
         */
        public $user;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * @param User $user The user whose avatar will be deleted.
         * @param User $actor The user performing the action.
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor)
        {
        }
    }
    class AvatarSaving
    {
        /**
         * The user whose avatar will be saved.
         *
         * @var User
         */
        public $user;
        /**
         * The user performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The image that will be saved.
         *
         * @var Image
         */
        public $image;
        /**
         * @param User $user The user whose avatar will be saved.
         * @param User $actor The user performing the action.
         * @param Image $image The image that will be saved.
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor, \Intervention\Image\Image $image)
        {
        }
    }
    class Deleted
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class Deleting
    {
        /**
         * The user who will be deleted.
         *
         * @var User
         */
        public $user;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * Any user input associated with the command.
         *
         * @var array
         */
        public $data;
        /**
         * @param User $user The user who will be deleted.
         * @param User $actor The user performing the action.
         * @param array $data Any user input associated with the command.
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor, array $data)
        {
        }
    }
    class EmailChanged
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class EmailChangeRequested
    {
        /**
         * The user who requested the email change.
         *
         * @var User
         */
        public $user;
        /**
         * The email they requested to change to.
         *
         * @var string
         */
        public $email;
        /**
         * @param User $user The user who requested the email change.
         * @param string $email The email they requested to change to.
         */
        public function __construct(\Flarum\User\User $user, $email)
        {
        }
    }
    class GroupsChanged
    {
        /**
         * The user whose groups were changed.
         *
         * @var User
         */
        public $user;
        /**
         * @var \Flarum\Group\Group[]
         */
        public $oldGroups;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user The user whose groups were changed.
         * @param \Flarum\Group\Group[] $oldGroups
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, array $oldGroups, \Flarum\User\User $actor = null)
        {
        }
    }
    class LoggedIn
    {
        public $user;
        public $token;
        public function __construct(\Flarum\User\User $user, \Flarum\Http\AccessToken $token)
        {
        }
    }
    class LoggedOut
    {
        public $user;
        public function __construct(\Flarum\User\User $user)
        {
        }
    }
    class PasswordChanged
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class Registered
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor = null)
        {
        }
    }
    class RegisteringFromProvider
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var string
         */
        public $provider;
        /**
         * @var array
         */
        public $payload;
        /**
         * @param User $user
         * @param $provider
         * @param $payload
         */
        public function __construct(\Flarum\User\User $user, string $provider, array $payload)
        {
        }
    }
    class Renamed
    {
        /**
         * @var User
         */
        public $user;
        /**
         * @var string
         */
        public $oldUsername;
        /**
         * @var User
         */
        public $actor;
        /**
         * @param User $user
         * @param string $oldUsername
         * @param User $actor
         */
        public function __construct(\Flarum\User\User $user, string $oldUsername, \Flarum\User\User $actor = null)
        {
        }
    }
    class Saving
    {
        /**
         * The user that will be saved.
         *
         * @var User
         */
        public $user;
        /**
         * The user who is performing the action.
         *
         * @var User
         */
        public $actor;
        /**
         * The attributes to update on the user.
         *
         * @var array
         */
        public $data;
        /**
         * @param User $user The user that will be saved.
         * @param User $actor The user who is performing the action.
         * @param array $data The attributes to update on the user.
         */
        public function __construct(\Flarum\User\User $user, \Flarum\User\User $actor, array $data)
        {
        }
    }
}
namespace Flarum\User\Exception {
    class InvalidConfirmationTokenException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
    class NotAuthenticatedException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
    class PermissionDeniedException extends \Exception implements \Flarum\Foundation\KnownError
    {
        public function getType() : string
        {
        }
    }
}
namespace Flarum\User\Filter {
    class UserFilterer extends \Flarum\Filter\AbstractFilterer
    {
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @param UserRepository $users
         * @param array $filters
         * @param array $filterMutators
         */
        public function __construct(\Flarum\User\UserRepository $users, array $filters, array $filterMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
}
namespace Flarum\User {
    /**
     * @property int $id
     * @property string $username
     * @property string $display_name
     * @property string $email
     * @property bool $is_email_confirmed
     * @property string $password
     * @property string|null $avatar_url
     * @property array $preferences
     * @property \Carbon\Carbon|null $joined_at
     * @property \Carbon\Carbon|null $last_seen_at
     * @property \Carbon\Carbon|null $marked_all_as_read_at
     * @property \Carbon\Carbon|null $read_notifications_at
     * @property int $discussion_count
     * @property int $comment_count
     * @mixin AbstractModel
     */
    class User extends \Flarum\Database\AbstractModel
    {
        use \Flarum\Foundation\EventGeneratorTrait;
        use \Flarum\Database\ScopeVisibilityTrait;
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['joined_at', 'last_seen_at', 'marked_all_as_read_at', 'read_notifications_at'];
        /**
         * An array of permissions that this user has.
         *
         * @var string[]|null
         */
        protected $permissions = null;
        /**
         * An array of callables, through each of which the user's list of groups is passed
         * before being returned.
         */
        protected static $groupProcessors = [];
        /**
         * An array of registered user preferences. Each preference is defined with
         * a key, and its value is an array containing the following keys:.
         *
         * - transformer: a callback that confines the value of the preference
         * - default: a default value if the preference isn't set
         *
         * @var array
         */
        protected static $preferences = [];
        /**
         * A driver for getting display names.
         *
         * @var DriverInterface
         */
        protected static $displayNameDriver;
        /**
         * The hasher with which to hash passwords.
         *
         * @var Hasher
         */
        protected static $hasher;
        /**
         * The access gate.
         *
         * @var Access\Gate
         */
        protected static $gate;
        /**
         * Callbacks to check passwords.
         *
         * @var array
         */
        protected static $passwordCheckers;
        /**
         * Boot the model.
         *
         * @return void
         */
        public static function boot()
        {
        }
        /**
         * Register a new user.
         *
         * @param string $username
         * @param string $email
         * @param string $password
         * @return static
         */
        public static function register($username, $email, $password)
        {
        }
        /**
         * @param Access\Gate $gate
         */
        public static function setGate($gate)
        {
        }
        /**
         * Set the display name driver.
         *
         * @param DriverInterface $driver
         */
        public static function setDisplayNameDriver(\Flarum\User\DisplayName\DriverInterface $driver)
        {
        }
        public static function setPasswordCheckers(array $checkers)
        {
        }
        /**
         * Rename the user.
         *
         * @param string $username
         * @return $this
         */
        public function rename($username)
        {
        }
        /**
         * Change the user's email.
         *
         * @param string $email
         * @return $this
         */
        public function changeEmail($email)
        {
        }
        /**
         * Request that the user's email be changed.
         *
         * @param string $email
         * @return $this
         */
        public function requestEmailChange($email)
        {
        }
        /**
         * Change the user's password.
         *
         * @param string $password
         * @return $this
         */
        public function changePassword($password)
        {
        }
        /**
         * Set the password attribute, storing it as a hash.
         *
         * @param string $value
         */
        public function setPasswordAttribute($value)
        {
        }
        /**
         * Mark all discussions as read.
         *
         * @return $this
         */
        public function markAllAsRead()
        {
        }
        /**
         * Mark all notifications as read.
         *
         * @return $this
         */
        public function markNotificationsAsRead()
        {
        }
        /**
         * Change the path of the user avatar.
         *
         * @param string $path
         * @return $this
         */
        public function changeAvatarPath($path)
        {
        }
        /**
         * Get the URL of the user's avatar.
         *
         * @todo Allow different storage locations to be used
         * @param string|null $value
         * @return string
         */
        public function getAvatarUrlAttribute(string $value = null)
        {
        }
        /**
         * Get the user's display name.
         *
         * @return string
         */
        public function getDisplayNameAttribute()
        {
        }
        /**
         * Check if a given password matches the user's password.
         *
         * @param string $password
         * @return bool
         */
        public function checkPassword($password)
        {
        }
        /**
         * Activate the user's account.
         *
         * @return $this
         */
        public function activate()
        {
        }
        /**
         * Check whether the user has a certain permission based on their groups.
         *
         * @param string $permission
         * @return bool
         */
        public function hasPermission($permission)
        {
        }
        /**
         * Check whether the user has a permission that is like the given string,
         * based on their groups.
         *
         * @param string $match
         * @return bool
         */
        public function hasPermissionLike($match)
        {
        }
        private function checkForDeprecatedPermissions($permission)
        {
        }
        /**
         * Get the notification types that should be alerted to this user, according
         * to their preferences.
         *
         * @return array
         */
        public function getAlertableNotificationTypes()
        {
        }
        /**
         * Get the number of unread notifications for the user.
         *
         * @return int
         */
        public function getUnreadNotificationCount()
        {
        }
        /**
         * Get all notifications that have not been read yet.
         *
         * @return \Illuminate\Database\Eloquent\Collection
         */
        protected function getUnreadNotifications()
        {
        }
        /**
         * Get the number of new, unseen notifications for the user.
         *
         * @return int
         */
        public function getNewNotificationCount()
        {
        }
        /**
         * Get the values of all registered preferences for this user, by
         * transforming their stored preferences and merging them with the defaults.
         *
         * @param string $value
         * @return array
         */
        public function getPreferencesAttribute($value)
        {
        }
        /**
         * Encode an array of preferences for storage in the database.
         *
         * @param mixed $value
         */
        public function setPreferencesAttribute($value)
        {
        }
        /**
         * Check whether or not the user should receive an alert for a notification
         * type.
         *
         * @param string $type
         * @return bool
         */
        public function shouldAlert($type)
        {
        }
        /**
         * Check whether or not the user should receive an email for a notification
         * type.
         *
         * @param string $type
         * @return bool
         */
        public function shouldEmail($type)
        {
        }
        /**
         * Get the value of a preference for this user.
         *
         * @param string $key
         * @param mixed $default
         * @return mixed
         */
        public function getPreference($key, $default = null)
        {
        }
        /**
         * Set the value of a preference for this user.
         *
         * @param string $key
         * @param mixed $value
         * @return $this
         */
        public function setPreference($key, $value)
        {
        }
        /**
         * Set the user as being last seen just now.
         *
         * @return $this
         */
        public function updateLastSeen()
        {
        }
        /**
         * Check whether or not the user is an administrator.
         *
         * @return bool
         */
        public function isAdmin()
        {
        }
        /**
         * Check whether or not the user is a guest.
         *
         * @return bool
         */
        public function isGuest()
        {
        }
        /**
         * Ensure the current user is allowed to do something.
         *
         * If the condition is not met, an exception will be thrown that signals the
         * lack of permissions. This is about *authorization*, i.e. retrying such a
         * request / operation without a change in permissions (or using another
         * user account) is pointless.
         *
         * @param bool $condition
         * @throws PermissionDeniedException
         */
        public function assertPermission($condition)
        {
        }
        /**
         * Ensure the given actor is authenticated.
         *
         * This will throw an exception for guest users, signaling that
         * *authorization* failed. Thus, they could retry the operation after
         * logging in (or using other means of authentication).
         *
         * @throws NotAuthenticatedException
         */
        public function assertRegistered()
        {
        }
        /**
         * @param string $ability
         * @param mixed $arguments
         * @throws PermissionDeniedException
         */
        public function assertCan($ability, $arguments = null)
        {
        }
        /**
         * @throws PermissionDeniedException
         */
        public function assertAdmin()
        {
        }
        /**
         * Define the relationship with the user's posts.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function posts()
        {
        }
        /**
         * Define the relationship with the user's discussions.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function discussions()
        {
        }
        /**
         * Define the relationship with the user's read discussions.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function read()
        {
        }
        /**
         * Define the relationship with the user's groups.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsToMany
         */
        public function groups()
        {
        }
        public function visibleGroups()
        {
        }
        /**
         * Define the relationship with the user's notifications.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function notifications()
        {
        }
        /**
         * Define the relationship with the user's email tokens.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function emailTokens()
        {
        }
        /**
         * Define the relationship with the permissions of all of the groups that
         * the user is in.
         *
         * @return \Illuminate\Database\Eloquent\Builder
         */
        public function permissions()
        {
        }
        /**
         * Get a list of permissions that the user has.
         *
         * @return string[]
         */
        public function getPermissions()
        {
        }
        /**
         * Define the relationship with the user's access tokens.
         *
         * @return \Illuminate\Database\Eloquent\Relations\HasMany
         */
        public function accessTokens()
        {
        }
        /**
         * Get the user's login providers.
         */
        public function loginProviders()
        {
        }
        /**
         * @param string $ability
         * @param array|mixed $arguments
         * @return bool
         */
        public function can($ability, $arguments = null)
        {
        }
        /**
         * @param string $ability
         * @param array|mixed $arguments
         * @return bool
         */
        public function cannot($ability, $arguments = null)
        {
        }
        /**
         * Set the hasher with which to hash passwords.
         *
         * @param Hasher $hasher
         *
         * @internal
         */
        public static function setHasher(\Illuminate\Contracts\Hashing\Hasher $hasher)
        {
        }
        /**
         * Register a preference with a transformer and a default value.
         *
         * @param string $key
         * @param callable $transformer
         * @param mixed $default
         *
         * @internal
         */
        public static function registerPreference($key, callable $transformer = null, $default = null)
        {
        }
        /**
         * Register a callback that processes a user's list of groups.
         *
         * @param callable $callback
         * @return array $groupIds
         *
         * @internal
         */
        public static function addGroupProcessor($callback)
        {
        }
        /**
         * Get the key for a preference which flags whether or not the user will
         * receive a notification for $type via $method.
         *
         * @param string $type
         * @param string $method
         * @return string
         */
        public static function getNotificationPreferenceKey($type, $method)
        {
        }
        /**
         * Refresh the user's comments count.
         *
         * @return $this
         */
        public function refreshCommentCount()
        {
        }
        /**
         * Refresh the user's comments count.
         *
         * @return $this
         */
        public function refreshDiscussionCount()
        {
        }
    }
    class Guest extends \Flarum\User\User
    {
        /**
         * Override the ID of this user, as a guest does not have an ID.
         *
         * @var int
         */
        public $id = 0;
        /**
         * Get the guest's group, containing only the 'guests' group model.
         *
         * @return \Flarum\Group\Group
         */
        public function getGroupsAttribute()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function isGuest()
        {
        }
    }
    class IdSlugDriver implements \Flarum\Http\SlugDriverInterface
    {
        /**
         * @var UserRepository
         */
        protected $users;
        public function __construct(\Flarum\User\UserRepository $users)
        {
        }
        public function toSlug(\Flarum\Database\AbstractModel $instance) : string
        {
        }
        public function fromSlug(string $slug, \Flarum\User\User $actor) : \Flarum\Database\AbstractModel
        {
        }
    }
    /**
     * @property int $id
     * @property int $user_id
     * @property string $provider
     * @property string $identifier
     * @property \Illuminate\Support\Carbon $created_at
     * @property \Illuminate\Support\Carbon $last_login_at
     * @property-read User $user
     */
    class LoginProvider extends \Flarum\Database\AbstractModel
    {
        protected $dates = ['created_at', 'last_login_at'];
        public $timestamps = true;
        const UPDATED_AT = 'last_login_at';
        protected $fillable = ['provider', 'identifier'];
        /**
         * Get the user that the login provider belongs to.
         */
        public function user()
        {
        }
        /**
         * Get the user associated with the provider so that they can be logged in.
         *
         * @param string $provider
         * @param string $identifier
         * @return User|null
         */
        public static function logIn(string $provider, string $identifier) : ?\Flarum\User\User
        {
        }
    }
    /**
     * @property string $token
     * @property \Carbon\Carbon $created_at
     * @property int $user_id
     */
    class PasswordToken extends \Flarum\Database\AbstractModel
    {
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at'];
        /**
         * Use a custom primary key for this model.
         *
         * @var bool
         */
        public $incrementing = false;
        /**
         * {@inheritdoc}
         */
        protected $primaryKey = 'token';
        /**
         * Generate a password token for the specified user.
         *
         * @param int $userId
         * @return static
         */
        public static function generate(int $userId)
        {
        }
        /**
         * Define the relationship with the owner of this password token.
         *
         * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
         */
        public function user()
        {
        }
    }
}
namespace Flarum\User\Query {
    class EmailFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * {@inheritdoc}
         */
        public function apply(\Flarum\Search\SearchState $search, $bit)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        protected function constrain(\Illuminate\Database\Query\Builder $query, $rawEmail, bool $negate)
        {
        }
    }
    class GroupFilterGambit extends \Flarum\Search\AbstractRegexGambit implements \Flarum\Filter\FilterInterface
    {
        /**
         * {@inheritdoc}
         */
        public function getGambitPattern()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function conditions(\Flarum\Search\SearchState $search, array $matches, $negate)
        {
        }
        public function getFilterKey() : string
        {
        }
        public function filter(\Flarum\Filter\FilterState $filterState, string $filterValue, bool $negate)
        {
        }
        protected function constrain(\Illuminate\Database\Query\Builder $query, \Flarum\User\User $actor, string $rawQuery, bool $negate)
        {
        }
    }
}
namespace Flarum\User {
    /**
     * @property string $token
     * @property string $provider
     * @property string $identifier
     * @property array $user_attributes
     * @property array $payload
     * @property \Carbon\Carbon $created_at
     */
    class RegistrationToken extends \Flarum\Database\AbstractModel
    {
        /**
         * The attributes that should be mutated to dates.
         *
         * @var array
         */
        protected $dates = ['created_at'];
        protected $casts = ['user_attributes' => 'array', 'payload' => 'array'];
        /**
         * Use a custom primary key for this model.
         *
         * @var bool
         */
        public $incrementing = false;
        /**
         * {@inheritdoc}
         */
        protected $primaryKey = 'token';
        /**
         * Generate an auth token for the specified user.
         *
         * @param string $provider
         * @param string $identifier
         * @param array $attributes
         * @param array $payload
         * @return static
         */
        public static function generate(string $provider, string $identifier, array $attributes, array $payload)
        {
        }
        /**
         * Find the token with the given ID, and assert that it has not expired.
         *
         * @param \Illuminate\Database\Eloquent\Builder $query
         * @param string $token
         *
         * @throws InvalidConfirmationTokenException
         *
         * @return RegistrationToken
         */
        public function scopeValidOrFail($query, string $token)
        {
        }
    }
}
namespace Flarum\User\Search\Gambit {
    class FulltextGambit implements \Flarum\Search\GambitInterface
    {
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @param \Flarum\User\UserRepository $users
         */
        public function __construct(\Flarum\User\UserRepository $users)
        {
        }
        /**
         * @param $searchValue
         * @return \Illuminate\Database\Eloquent\Builder
         */
        private function getUserSearchSubQuery($searchValue)
        {
        }
        /**
         * {@inheritdoc}
         */
        public function apply(\Flarum\Search\SearchState $search, $searchValue)
        {
        }
    }
}
namespace Flarum\User\Search {
    class UserSearcher extends \Flarum\Search\AbstractSearcher
    {
        /**
         * @var Dispatcher
         */
        protected $events;
        /**
         * @var UserRepository
         */
        protected $users;
        /**
         * @param UserRepository $users
         * @param Dispatcher $events
         * @param GambitManager $gambits
         * @param array $searchMutators
         */
        public function __construct(\Flarum\User\UserRepository $users, \Illuminate\Contracts\Events\Dispatcher $events, \Flarum\Search\GambitManager $gambits, array $searchMutators)
        {
        }
        protected function getQuery(\Flarum\User\User $actor) : \Illuminate\Database\Eloquent\Builder
        {
        }
    }
}
namespace Flarum\User {
    class SelfDemotionGuard
    {
        /**
         * Prevent an admin from removing their admin permission via the API.
         * @param Saving $event
         * @throws PermissionDeniedException
         */
        public function handle(\Flarum\User\Event\Saving $event)
        {
        }
    }
    class SessionServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
    }
    class UserMetadataUpdater
    {
        /**
         * @param Dispatcher $events
         */
        public function subscribe(\Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
        /**
         * @param \Flarum\Post\Event\Posted $event
         */
        public function whenPostWasPosted(\Flarum\Post\Event\Posted $event)
        {
        }
        /**
         * @param \Flarum\Post\Event\Deleted $event
         */
        public function whenPostWasDeleted(\Flarum\Post\Event\Deleted $event)
        {
        }
        /**
         * @param \Flarum\Discussion\Event\Started $event
         */
        public function whenDiscussionWasStarted(\Flarum\Discussion\Event\Started $event)
        {
        }
        /**
         * @param \Flarum\Discussion\Event\Deleted $event
         */
        public function whenDiscussionWasDeleted(\Flarum\Discussion\Event\Deleted $event)
        {
        }
        /**
         * @param \Flarum\User\User $user
         */
        private function updateCommentsCount(?\Flarum\User\User $user)
        {
        }
        private function updateDiscussionsCount(\Flarum\Discussion\Discussion $discussion)
        {
        }
    }
    class UsernameSlugDriver implements \Flarum\Http\SlugDriverInterface
    {
        /**
         * @var UserRepository
         */
        protected $users;
        public function __construct(\Flarum\User\UserRepository $users)
        {
        }
        public function toSlug(\Flarum\Database\AbstractModel $instance) : string
        {
        }
        public function fromSlug(string $slug, \Flarum\User\User $actor) : \Flarum\Database\AbstractModel
        {
        }
    }
    class UserRepository
    {
        /**
         * Get a new query builder for the users table.
         *
         * @return \Illuminate\Database\Eloquent\Builder
         */
        public function query()
        {
        }
        /**
         * Find a user by ID, optionally making sure it is visible to a certain
         * user, or throw an exception.
         *
         * @param int $id
         * @param User|null $actor
         * @return User|Model
         */
        public function findOrFail($id, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Find a user by username, optionally making sure it is visible to a certain
         * user, or throw an exception.
         *
         * @param int $username
         * @param User|null $actor
         * @return User|Model
         */
        public function findOrFailByUsername($username, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Find a user by an identification (username or email).
         *
         * @param string $identification
         * @return User|null|Model
         */
        public function findByIdentification($identification)
        {
        }
        /**
         * Find a user by email.
         *
         * @param string $email
         * @return User|null|Model
         */
        public function findByEmail($email)
        {
        }
        /**
         * Get the ID of a user with the given username.
         *
         * @param string $username
         * @param User|null $actor
         * @return int|null
         */
        public function getIdForUsername($username, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Find users by matching a string of words against their username,
         * optionally making sure they are visible to a certain user.
         *
         * @param string $string
         * @param User|null $actor
         * @return array
         */
        public function getIdsForUsername($string, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Scope a query to only include records that are visible to a user.
         *
         * @param Builder $query
         * @param User|null $actor
         * @return Builder
         */
        protected function scopeVisibleTo(\Illuminate\Database\Eloquent\Builder $query, \Flarum\User\User $actor = null)
        {
        }
        /**
         * Escape special characters that can be used as wildcards in a LIKE query.
         *
         * @param string $string
         * @return string
         */
        private function escapeLikeString($string)
        {
        }
    }
    class UserServiceProvider extends \Flarum\Foundation\AbstractServiceProvider
    {
        /**
         * {@inheritdoc}
         */
        public function register()
        {
        }
        protected function registerDisplayNameDrivers()
        {
        }
        protected function registerPasswordCheckers()
        {
        }
        /**
         * {@inheritdoc}
         */
        public function boot(\Illuminate\Contracts\Container\Container $container, \Illuminate\Contracts\Events\Dispatcher $events)
        {
        }
    }
    class UserValidator extends \Flarum\Foundation\AbstractValidator
    {
        /**
         * @var User
         */
        protected $user;
        /**
         * @return User
         */
        public function getUser()
        {
        }
        /**
         * @param User $user
         */
        public function setUser(\Flarum\User\User $user)
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function getRules()
        {
        }
        /**
         * {@inheritdoc}
         */
        protected function getMessages()
        {
        }
    }
}
namespace {
    /**
     * Resolve a service from the container.
     *
     * @template T
     * @param  class-string<T>|string  $name
     * @param  array  $parameters
     * @return T|mixed
     */
    function resolve($name, $parameters = [])
    {
    }
    /**
     * @deprecated perpetually.
     *
     * @param  string  $make
     * @param  array   $parameters
     * @return mixed|\Illuminate\Container\Container
     */
    function app($make = \null, $parameters = [])
    {
    }
    /**
     * @deprecated perpetually.
     *
     * Get the path to the base of the install.
     *
     * @param  string  $path
     * @return string
     */
    function base_path($path = '')
    {
    }
    /**
     * @deprecated perpetually.
     *
     * Get the path to the public folder.
     *
     * @param  string  $path
     * @return string
     */
    function public_path($path = '')
    {
    }
    /**
     * @deprecated perpetually.
     *
     * Get the path to the storage folder.
     *
     * @param  string  $path
     * @return string
     */
    function storage_path($path = '')
    {
    }
    /**
     * @deprecated perpetually.
     *
     * Fire an event and call the listeners.
     *
     * @param  string|object  $event
     * @param  mixed  $payload
     * @param  bool  $halt
     * @return array|null
     */
    function event($event, $payload = [], $halt = \false)
    {
    }
    /**
     * @deprecated do not use, will be transferred to flarum/laravel-helpers.
     */
    function config(string $key, $default = \null)
    {
    }
}